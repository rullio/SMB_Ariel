/**
 ******************************************************************************
 * File Name          : smb_thread_init.c
 * Description        : This file is generated by 위대한 송 인재 on Aug 24, 2025
 ******************************************************************************
 *
 * COPYRIGHT(c) 2024 DSN Co. Ltd.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *   1. Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *   3. Neither the name of STMicroelectronics nor the names of its contributors
 *      may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************
 */

#include "main.h"

bool eflash_ifc_init(void *arg);
bool LittleFS_init(void);
bool get_SMB_config (SMB_ConfigObj_t *pconfig);
bool get_factory_default (SMB_ConfigObj_t *pconfig);
bool osTimerList_init(osTimerEntry_t osTimerList[]);

static bool SMBIntrObj_init(SMBIntrObj_t *psio)
{
	memset ((void *)psio, 0, sizeof(SMBIntrObj_t));
	return true;
}

static bool SMBConfigObj_init(SMB_ConfigObj_t *pconfig)
{
	if (get_SMB_config(pconfig) != true) {
		assert (get_factory_default(pconfig) == true);
		save_smb_configObj_onto_fs(pconfig);
	}

	return true;
}

static bool SMBStatusObj_init(SMB_StatusObj_t *pStatusObj)
{
	memset(pStatusObj, 0, sizeof(SMB_StatusObj_t));

	pStatusObj->implementer = LL_CPUID_GetImplementer();
	pStatusObj->variant = LL_CPUID_GetVariant();
	pStatusObj->constant = LL_CPUID_GetConstant();
	pStatusObj->partno = LL_CPUID_GetParNo();
	pStatusObj->version = LL_CPUID_GetRevision();
	pStatusObj->package_type = LL_GetPackageType();

	assert (pStatusObj->implementer == 0x41);
	assert (pStatusObj->variant == 0);
	assert (pStatusObj->constant == 0x0f);
	assert (pStatusObj->partno == 0xC24);
	assert (pStatusObj->version == 0x1);
	assert (pStatusObj->package_type == LL_UTILS_PACKAGETYPE_LQFP144_CSP72);

	pStatusObj->uid0 = LL_GetUID_Word0();
	pStatusObj->uid1 = LL_GetUID_Word1();
	pStatusObj->uid2 = LL_GetUID_Word2();

	strcpy(pStatusObj->fw_version, FW_VERSION);

	assert (HAL_RTC_GetTime(&hrtc, &pStatusObj->currentTime, RTC_FORMAT_BCD) == HAL_OK);
	assert (HAL_RTC_GetDate(&hrtc, &pStatusObj->currentDate, RTC_FORMAT_BCD) == HAL_OK);
	memcpy (&pStatusObj->launchTime, &pStatusObj->currentTime, sizeof(RTC_TimeTypeDef));
	memcpy (&pStatusObj->launchDate, &pStatusObj->currentDate, sizeof(RTC_TimeTypeDef));

	pStatusObj->uptime_counter = 0;
	pStatusObj->ims_packet_error_counter = 0;

	pStatusObj->smb_data_show_flag = false;
	pStatusObj->peri_manual_control_flag = false;

	pStatusObj->smb_luminance.bright_or_dark = LUMINANCE_BRIGHT;
	pStatusObj->smb_luminance.luminance = 0;
	pStatusObj->smb_luminance.luminance_threshold = SMB_ConfigObj.luminance_threshold;
	pStatusObj->smb_motion.sonic_threshold = SMB_ConfigObj.sonic_threshold;
	pStatusObj->rb_working = true;		// test 용으로 잠시 true 로 만듬
	pStatusObj->smb_manipulation = false;

	return true;
}

static bool SMBControlObj_init(SMB_ControlObj_t *pControlObj)
{
	/*******************************************************************************
	 LEDBAR Object
	 *******************************************************************************/
	ledbarObj_init(&pControlObj->ledbarObj);
	pControlObj->ledbarObj.ledbar_color_set(LEDBAR_OFF);

	/*******************************************************************************
	 SIREN Object
	 *******************************************************************************/
	sirenObj_init(&pControlObj->sirenObj);
	pControlObj->sirenObj.siren_set(SIREN_OFF);

	/*******************************************************************************
	 LTE Power Object
	 *******************************************************************************/
	lteObj_init(&pControlObj->lteObj);
	pControlObj->lteObj.lte_set(LTE_OFF);

	/*******************************************************************************
	 PTC Power Object
	 *******************************************************************************/
	ptcObj_init(&pControlObj->ptcObj);
	pControlObj->ptcObj.ptc_set(PTC_OFF);

	/*******************************************************************************
	 YUCHAR Object
	 *******************************************************************************/
	yucharObj_init(&pControlObj->yucharObj);
	pControlObj->yucharObj.yuchar_set(YUCHAR_OFF);

	/*******************************************************************************
	 MUCHAR1 Object
	 *******************************************************************************/
	muchar1Obj_init(&pControlObj->muchar1Obj);
	pControlObj->muchar1Obj.muchar1_set(MUCHAR1_OFF);

	/*******************************************************************************
	 MUCHAR2 Object
	 *******************************************************************************/
	muchar2Obj_init(&pControlObj->muchar2Obj);
	pControlObj->muchar2Obj.muchar2_set(MUCHAR2_OFF);

	/*******************************************************************************
	 FAN Object
	 *******************************************************************************/
	fanObj_init(&pControlObj->fanObj);
	pControlObj->fanObj.fan_set(FAN_OFF);

	/*******************************************************************************
	 INVERTER Object
	 *******************************************************************************/
	inverterObj_init(&pControlObj->inverterObj);
	pControlObj->inverterObj.inverter_set(INVERTER_OFF);

	/*******************************************************************************
	 SPEAKER Object
	 TPA3136D2 (TI Class-D Audio Amp 의 /SD pin 으로 연결됨) High 줘야 Amp output enable.
	 *******************************************************************************/
	speakerObj_init(&pControlObj->speakerObj);
	pControlObj->speakerObj.speaker_set(SPEAKER_OFF);

	/*******************************************************************************
	 LCD Object
	 *******************************************************************************/
	lcdObj_init(&pControlObj->lcdObj);
	pControlObj->lcdObj.lcd_set(LCD_OFF);

	/*******************************************************************************
	 LAMP Object
	 *******************************************************************************/
	lampObj_init(&pControlObj->lampObj);
	pControlObj->lampObj.lamp_set(LAMP_OFF);

	return true;
}

void smb_thread_init (void *arg)
{
	DbgTraceInit();
	assert (SMBIntrObj_init(&SMBIntrObj) == true);
	assert (eflash_ifc_init(NULL) == true);
	assert (LittleFS_init() == true);
	assert (SMBConfigObj_init(&SMB_ConfigObj) == true);
	assert (SMBStatusObj_init(&SMB_StatusObj) == true);
	assert (SMBControlObj_init(&SMB_ControlObj) == true);
	assert (SMB_ManiObj_backup(&SMB_ManiObj, &SMB_ControlObj) == true);
	assert (osTimerList_init(osTimerList) == true);

	HAL_Delay(100);

	osThreadExit();
}
