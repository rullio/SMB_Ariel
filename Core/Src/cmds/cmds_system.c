/**
 ******************************************************************************
 * File Name          : cmds_system.c
 * Description        : This file is generated by Jay.
 ******************************************************************************
 *
 * COPYRIGHT(c) 2024 LMS Co. Ltd.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *   1. Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *   3. Neither the name of STMicroelectronics nor the names of its contributors
 *      may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************
 */

#include "main.h"

extern RNG_HandleTypeDef hrng;
void SystemClock_Config(void);

extern uint64_t up_time_counter;

static void smb_cmd_clearScreen (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	(*pCmdIO->pCmdApi->msg)(cmdIoParam,  CUI_ESC_CLR);
	(*pCmdIO->pCmdApi->msg)(cmdIoParam,  CUI_ESC_CUR_HOME);
	return;
}

static void smb_cmd_show_system (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	uint32_t CPUID;
	uint32_t implementer, variant, constant, partno, version;
	uint32_t package_type;
	uint32_t firewall;
	uint32_t exti_line_no[16], exti_port;
	uint32_t flash_size, flash_bank_mode;
	uint32_t systick_clk_source, systick_enabled_it, mpu_enabled;
	uint32_t uid0, uid1, uid2;
	osVersion_t osv;
	osStatus_t status;
	char infobuf[100];

	// CPU ID
	CPUID = READ_REG(SCB->CPUID);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "CPUID=%#010"PRIx32 LINE_TERM, CPUID);

	implementer = LL_CPUID_GetImplementer();
	variant = LL_CPUID_GetVariant();
	constant = LL_CPUID_GetConstant();
	partno = LL_CPUID_GetParNo();
	version = LL_CPUID_GetRevision();

	assert (implementer == 0x41);
	assert (variant == 0);
	assert (constant == 0x0f);
	assert (partno == 0xC24);
	assert (version == 0x1);

	if (implementer == 0x41) (*pCmdIO->pCmdApi->msg)(cmdIoParam, "implementer = Arm"LINE_TERM);
	if (partno == 0xC24) (*pCmdIO->pCmdApi->msg)(cmdIoParam, "partno = Cortex-M4"LINE_TERM);

	// Package type
	package_type = LL_GetPackageType();
	(*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, "MCU package_type = ");
	switch (package_type) {
	case LL_UTILS_PACKAGETYPE_LQFP64 : (*pCmdIO->pCmdApi->msg)(cmdIoParam, "LL_UTILS_PACKAGETYPE_LQFP64"LINE_TERM); break;
	case LL_UTILS_PACKAGETYPE_WLCSP64 : (*pCmdIO->pCmdApi->msg)(cmdIoParam, "LL_UTILS_PACKAGETYPE_WLCSP64"LINE_TERM); break;
	case LL_UTILS_PACKAGETYPE_LQFP100 : (*pCmdIO->pCmdApi->msg)(cmdIoParam, "LL_UTILS_PACKAGETYPE_LQFP100"LINE_TERM); break;
	case LL_UTILS_PACKAGETYPE_BGA132 : (*pCmdIO->pCmdApi->msg)(cmdIoParam, "LL_UTILS_PACKAGETYPE_BGA132"LINE_TERM); break;
	case LL_UTILS_PACKAGETYPE_LQFP144_CSP72 : (*pCmdIO->pCmdApi->msg)(cmdIoParam, "LL_UTILS_PACKAGETYPE_LQFP144_CSP72"LINE_TERM); break;
	case LL_UTILS_PACKAGETYPE_UFQFPN32 : (*pCmdIO->pCmdApi->msg)(cmdIoParam, "LL_UTILS_PACKAGETYPE_UFQFPN32"LINE_TERM); break;
	case LL_UTILS_PACKAGETYPE_UFQFPN48 : (*pCmdIO->pCmdApi->msg)(cmdIoParam, "LL_UTILS_PACKAGETYPE_UFQFPN48"LINE_TERM); break;
	case LL_UTILS_PACKAGETYPE_LQFP48 : (*pCmdIO->pCmdApi->msg)(cmdIoParam, "LL_UTILS_PACKAGETYPE_LQFP48"LINE_TERM); break;
	case LL_UTILS_PACKAGETYPE_WLCSP49 : (*pCmdIO->pCmdApi->msg)(cmdIoParam, "LL_UTILS_PACKAGETYPE_WLCSP49"LINE_TERM); break;
	case LL_UTILS_PACKAGETYPE_UFBGA64 : (*pCmdIO->pCmdApi->msg)(cmdIoParam, "LL_UTILS_PACKAGETYPE_UFBGA64"LINE_TERM); break;
	case LL_UTILS_PACKAGETYPE_UFBGA100 : (*pCmdIO->pCmdApi->msg)(cmdIoParam, "LL_UTILS_PACKAGETYPE_UFBGA100"LINE_TERM); break;
	case LL_UTILS_PACKAGETYPE_UFBGA169_CSP115 : (*pCmdIO->pCmdApi->msg)(cmdIoParam, "LL_UTILS_PACKAGETYPE_UFBGA169_CSP115"LINE_TERM); break;
	case LL_UTILS_PACKAGETYPE_LQFP100_DSI : (*pCmdIO->pCmdApi->msg)(cmdIoParam, "LL_UTILS_PACKAGETYPE_LQFP100_DSI"LINE_TERM); break;
	case LL_UTILS_PACKAGETYPE_WLCSP144_DSI : (*pCmdIO->pCmdApi->msg)(cmdIoParam, "LL_UTILS_PACKAGETYPE_WLCSP144_DSI or LL_UTILS_PACKAGETYPE_UFBGA144_DSI"LINE_TERM); break;
	case LL_UTILS_PACKAGETYPE_UFBGA169_DSI : (*pCmdIO->pCmdApi->msg)(cmdIoParam, "LL_UTILS_PACKAGETYPE_UFBGA169_DSI"LINE_TERM); break;
	case LL_UTILS_PACKAGETYPE_LQFP144_DSI : (*pCmdIO->pCmdApi->msg)(cmdIoParam, "LL_UTILS_PACKAGETYPE_LQFP144_DSI"LINE_TERM); break;
	default : (*pCmdIO->pCmdApi->msg)(cmdIoParam, "UNDEFINED !!"LINE_TERM); assert (0 == 1); break;
	}

	// UID. Reference manual 의 Device electronic signature 참조할 것.
	uid0 = LL_GetUID_Word0();
	uid1 = LL_GetUID_Word1();
	uid2 = LL_GetUID_Word2();
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "uid0=%#010"PRIx32 LINE_TERM, uid0);	// X and Y coordinates on the wafer
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "uid1=%#010"PRIx32 LINE_TERM, uid1);	// LOT_NUM[23:0], WAFER_NUM[7:0]
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "uid2=%#010"PRIx32 LINE_TERM, uid2);	// Lot number (ASCII encoded)

	// OS
	status = osKernelGetInfo(&osv, infobuf, sizeof(infobuf));
	assert (status == osOK);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "Kernel Information: %s"LINE_TERM, infobuf);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "Kernel Version    : %d"LINE_TERM, osv.kernel);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "Kernel API Version: %d"LINE_TERM, osv.api);

	systick_clk_source = LL_SYSTICK_GetClkSource();
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "systick clock source = %s"LINE_TERM, (systick_clk_source == 1)?"LL_SYSTICK_CLKSOURCE_HCLK":"LL_SYSTICK_CLKSOURCE_HCLK_DIV8");
	systick_enabled_it = LL_SYSTICK_IsEnabledIT();
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "systick_enabled_it = %s"LINE_TERM, (systick_enabled_it == 1)?"ENABLED":"DISABLED");
	mpu_enabled = LL_MPU_IsEnabled();
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "MPU = %s"LINE_TERM, (mpu_enabled == 1)?"ENABLED":"DISABLED");
	flash_size = LL_GetFlashSize();
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "flash_size = %d KB"LINE_TERM, flash_size);
	flash_bank_mode = LL_SYSCFG_GetFlashBankMode();
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "flash_bank_mode = %s : ", (flash_bank_mode == LL_SYSCFG_BANKMODE_BANK1)?"LL_SYSCFG_BANKMODE_BANK1":"LL_SYSCFG_BANKMODE_BANK2");
	if (flash_bank_mode == LL_SYSCFG_BANKMODE_BANK1) {
		(*pCmdIO->pCmdApi->msg)(cmdIoParam, "Flash Bank1 : 0x08000000"LINE_TERM);
		(*pCmdIO->pCmdApi->msg)(cmdIoParam, "Flash Bank2 : 0x08080000"LINE_TERM);
	}
	else {
		(*pCmdIO->pCmdApi->msg)(cmdIoParam, "Flash Bank2 : 0x08000000"LINE_TERM);
		(*pCmdIO->pCmdApi->msg)(cmdIoParam, "Flash Bank1 : 0x08080000"LINE_TERM);
	}
	firewall = LL_SYSCFG_IsEnabledFirewall();
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "Firewall = %s"LINE_TERM, (firewall == 1)?"ENABLED":"DISABLED");

	// SYSTEM_LL_EC_EXTI_PORT SYSCFG EXTI PORT
	exti_line_no[0] = LL_SYSCFG_EXTI_LINE0;
	exti_line_no[1] = LL_SYSCFG_EXTI_LINE1;
	exti_line_no[2] = LL_SYSCFG_EXTI_LINE2;
	exti_line_no[3] = LL_SYSCFG_EXTI_LINE3;
	exti_line_no[4] = LL_SYSCFG_EXTI_LINE4;
	exti_line_no[5] = LL_SYSCFG_EXTI_LINE5;
	exti_line_no[6] = LL_SYSCFG_EXTI_LINE6;
	exti_line_no[7] = LL_SYSCFG_EXTI_LINE7;
	exti_line_no[8] = LL_SYSCFG_EXTI_LINE8;
	exti_line_no[9] = LL_SYSCFG_EXTI_LINE9;
	exti_line_no[10] = LL_SYSCFG_EXTI_LINE10;
	exti_line_no[11] = LL_SYSCFG_EXTI_LINE11;
	exti_line_no[12] = LL_SYSCFG_EXTI_LINE12;
	exti_line_no[13] = LL_SYSCFG_EXTI_LINE13;
	exti_line_no[14] = LL_SYSCFG_EXTI_LINE14;
	exti_line_no[15] = LL_SYSCFG_EXTI_LINE15;

	for (uint32_t i = 0 ; i < 16 ; i++) {
		exti_port = LL_SYSCFG_GetEXTISource(exti_line_no[i]);
		switch (exti_port) {
		case LL_SYSCFG_EXTI_PORTA : (*pCmdIO->pCmdApi->print)(cmdIoParam, "LL_SYSCFG_EXTI_LINE_%d : LL_SYSCFG_EXTI_PORTA"LINE_TERM, i); break;
		case LL_SYSCFG_EXTI_PORTB : (*pCmdIO->pCmdApi->print)(cmdIoParam, "LL_SYSCFG_EXTI_LINE_%d : LL_SYSCFG_EXTI_PORTB"LINE_TERM, i); break;
		case LL_SYSCFG_EXTI_PORTC : (*pCmdIO->pCmdApi->print)(cmdIoParam, "LL_SYSCFG_EXTI_LINE_%d : LL_SYSCFG_EXTI_PORTC"LINE_TERM, i); break;
		case LL_SYSCFG_EXTI_PORTD : (*pCmdIO->pCmdApi->print)(cmdIoParam, "LL_SYSCFG_EXTI_LINE_%d : LL_SYSCFG_EXTI_PORTD"LINE_TERM, i); break;
		case LL_SYSCFG_EXTI_PORTE : (*pCmdIO->pCmdApi->print)(cmdIoParam, "LL_SYSCFG_EXTI_LINE_%d : LL_SYSCFG_EXTI_PORTE"LINE_TERM, i); break;
		case LL_SYSCFG_EXTI_PORTF : (*pCmdIO->pCmdApi->print)(cmdIoParam, "LL_SYSCFG_EXTI_LINE_%d : LL_SYSCFG_EXTI_PORTF"LINE_TERM, i); break;
		case LL_SYSCFG_EXTI_PORTG : (*pCmdIO->pCmdApi->print)(cmdIoParam, "LL_SYSCFG_EXTI_LINE_%d : LL_SYSCFG_EXTI_PORTG"LINE_TERM, i); break;
		case LL_SYSCFG_EXTI_PORTH : (*pCmdIO->pCmdApi->print)(cmdIoParam, "LL_SYSCFG_EXTI_LINE_%d : LL_SYSCFG_EXTI_PORTH"LINE_TERM, i); break;
		case LL_SYSCFG_EXTI_PORTI : (*pCmdIO->pCmdApi->print)(cmdIoParam, "LL_SYSCFG_EXTI_LINE_%d : LL_SYSCFG_EXTI_PORTI"LINE_TERM, i); break;
		default : assert (0 == 1); break;
		}
	}

	return;
}

#if 0
typedef struct xTASK_STATUS
{
	TaskHandle_t xHandle;			/* The handle of the task to which the rest of the information in the structure relates. */
	const char *pcTaskName;			/* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
	UBaseType_t xTaskNumber;		/* A number unique to the task. */
	eTaskState eCurrentState;		/* The state in which the task existed when the structure was populated. */
	UBaseType_t uxCurrentPriority;	/* The priority at which the task was running (may be inherited) when the structure was populated. */
	UBaseType_t uxBasePriority;		/* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */
	uint32_t ulRunTimeCounter;		/* The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */
	StackType_t *pxStackBase;		/* Points to the lowest address of the task's stack area. */
	configSTACK_DEPTH_TYPE usStackHighWaterMark;	/* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */
} TaskStatus_t;

/* Task states returned by eTaskGetState. */
typedef enum
{
	eRunning = 0,	/* A task is querying the state of itself, so must be running. */
	eReady,			/* The task being queried is in a read or pending ready list. */
	eBlocked,		/* The task being queried is in the Blocked state. */
	eSuspended,		/* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */
	eDeleted,		/* The task being queried has been deleted, but its TCB has not yet been freed. */
	eInvalid		/* Used as an 'invalid state' value. */
} eTaskState;
#endif
static void smb_cmd_taskinfo (SYS_CMD_DEVICE_NODE *pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	TaskStatus_t *pxTaskStatusArray;
	volatile UBaseType_t uxArraySize, x;
	unsigned long ulTotalRunTime, ulStatsAsPercentage;

	uxArraySize = uxTaskGetNumberOfTasks ();
	(*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM "Total %d tasks are running now.." LINE_TERM, uxArraySize);

	/* Allocate a TaskStatus_t structure for each task.  An array could be allocated statically at compile time. */
	pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );

	if( pxTaskStatusArray != NULL ) {
		/* Generate raw status information about each task. */
		uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize,	&ulTotalRunTime );
		for( x = 0; x < uxArraySize; x++ ) {
			(*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM "The %dth : %s", x+1, pxTaskStatusArray[ x ].pcTaskName);
			(*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM "xTaskNumber = %d", pxTaskStatusArray[ x ].xTaskNumber);
			switch (pxTaskStatusArray[ x ].eCurrentState) {
			case eRunning : (*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM " %s is eRunning", pxTaskStatusArray[ x ].pcTaskName); break;
			case eReady : (*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM " %s is eReady", pxTaskStatusArray[ x ].pcTaskName); break;
			case eBlocked : (*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM " %s is eBlocked", pxTaskStatusArray[ x ].pcTaskName); break;
			case eSuspended : (*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM " %s is eSuspended", pxTaskStatusArray[ x ].pcTaskName); break;
			case eDeleted : (*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM " %s is eDeleted", pxTaskStatusArray[ x ].pcTaskName); break;
			case eInvalid : (*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM " %s is eInvalid", pxTaskStatusArray[ x ].pcTaskName); break;
			default : (*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM " %s' eCurrentState is UNKNOWN !!", pxTaskStatusArray[ x ].pcTaskName); break;
			}
			(*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM "uxCurrentPriority = %d", pxTaskStatusArray[ x ].uxCurrentPriority);
			(*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM "uxBasePriority = %d", pxTaskStatusArray[ x ].uxBasePriority);
			(*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM "ulRunTimeCounter = %d", pxTaskStatusArray[ x ].ulRunTimeCounter);
			(*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM "pxStackBase = %#06"PRIx16, pxTaskStatusArray[ x ].usStackHighWaterMark);
			(*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM "usStackHighWaterMark = %d", pxTaskStatusArray[ x ].usStackHighWaterMark);
			(*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM);
			//			osDelay(1);	// display 하다가 잘리는 현상 방지용. Queue buffer 를 8K 로 만들었으니 이제 필요없다.
		}

		// 아래는 running time 만 표시하는 루틴..
		/* For percentage calculations. */
		ulTotalRunTime /= 100UL;

		/* Avoid divide by zero errors. */
		if( ulTotalRunTime > 0 ) {
			/* For each populated position in the pxTaskStatusArray array,
	         format the raw data as human readable ASCII data. */
			for( x = 0; x < uxArraySize; x++ ) {
				/* What percentage of the total run time has the task used?
	            This will always be rounded down to the nearest integer.
	            ulTotalRunTimeDiv100 has already been divided by 100. */
				ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;

				if( ulStatsAsPercentage > 0UL )	{
					(*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM "%stt%lutt%lu%%rn",	\
							pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter,	ulStatsAsPercentage );
				}
				else {
					/* If the percentage is zero here then the task has
	               consumed less than 1% of the total run time. */
					(*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM "%stt%lutt<1%%rn", \
							pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter);
				}
			}
		}
		else {
			(*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM "Actual running time is < 1");
			(*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM);
		}

		/* The array is no longer needed, free the memory it consumes. */
		vPortFree( pxTaskStatusArray );
	}
	else {
		(*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM "pvPortMalloc () return NULL");
		(*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM);
	}

	return;
}

static void smb_cmd_rtc_showtime (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	RTC_TimeTypeDef sTime;
	RTC_DateTypeDef sDate;

	(*pCmdIO->pCmdApi->print)(cmdIoParam, " Time format = %s format"LINE_TERM, (hrtc.Instance->CR & RTC_CR_FMT)?"AM/PM hour":"24 hour/day");
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, " RTC Time info =\t");

	assert (HAL_RTC_GetDate(&hrtc, &sDate, RTC_FORMAT_BCD) == HAL_OK);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "%4d/%02d/%02d ", 2000 + RTC_Bcd2ToByte(sDate.Year), RTC_Bcd2ToByte(sDate.Month), RTC_Bcd2ToByte(sDate.Date));

	switch (RTC_Bcd2ToByte(RTC_Bcd2ToByte(sDate.WeekDay))) {
	case RTC_WEEKDAY_MONDAY : 		(*pCmdIO->pCmdApi->print)(cmdIoParam, "(Mon)"); break;
	case RTC_WEEKDAY_TUESDAY : 		(*pCmdIO->pCmdApi->print)(cmdIoParam, "(Tue)"); break;
	case RTC_WEEKDAY_WEDNESDAY : 	(*pCmdIO->pCmdApi->print)(cmdIoParam, "(Wed)"); break;
	case RTC_WEEKDAY_THURSDAY : 	(*pCmdIO->pCmdApi->print)(cmdIoParam, "(Thu)"); break;
	case RTC_WEEKDAY_FRIDAY : 		(*pCmdIO->pCmdApi->print)(cmdIoParam, "(Fri)"); break;
	case RTC_WEEKDAY_SATURDAY : 	(*pCmdIO->pCmdApi->print)(cmdIoParam, "(Sat)"); break;
	case RTC_WEEKDAY_SUNDAY : 		(*pCmdIO->pCmdApi->print)(cmdIoParam, "(Sun)"); break;
	default : 						assert (0 == 1); break;
	}

	assert (HAL_RTC_GetTime(&hrtc, &sTime, RTC_FORMAT_BCD) == HAL_OK);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, " %d : %d : %d"LINE_TERM,	RTC_Bcd2ToByte(sTime.Hours), RTC_Bcd2ToByte(sTime.Minutes),	RTC_Bcd2ToByte(sTime.Seconds));

	(*pCmdIO->pCmdApi->msg)(cmdIoParam, " SMB_Status Time info =\t");
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "%4d/%02d/%02d ", 2000 + RTC_Bcd2ToByte(SMB_StatusObj.currentDate.Year), RTC_Bcd2ToByte(SMB_StatusObj.currentDate.Month), RTC_Bcd2ToByte(SMB_StatusObj.currentDate.Date));

	switch (RTC_Bcd2ToByte(RTC_Bcd2ToByte(SMB_StatusObj.currentDate.WeekDay))) {
	case RTC_WEEKDAY_MONDAY : 		(*pCmdIO->pCmdApi->print)(cmdIoParam, "(Mon)"); break;
	case RTC_WEEKDAY_TUESDAY : 		(*pCmdIO->pCmdApi->print)(cmdIoParam, "(Tue)"); break;
	case RTC_WEEKDAY_WEDNESDAY : 	(*pCmdIO->pCmdApi->print)(cmdIoParam, "(Wed)"); break;
	case RTC_WEEKDAY_THURSDAY : 	(*pCmdIO->pCmdApi->print)(cmdIoParam, "(Thu)"); break;
	case RTC_WEEKDAY_FRIDAY : 		(*pCmdIO->pCmdApi->print)(cmdIoParam, "(Fri)"); break;
	case RTC_WEEKDAY_SATURDAY : 	(*pCmdIO->pCmdApi->print)(cmdIoParam, "(Sat)"); break;
	case RTC_WEEKDAY_SUNDAY : 		(*pCmdIO->pCmdApi->print)(cmdIoParam, "(Sun)"); break;
	default : 						assert (0 == 1); break;
	}

	(*pCmdIO->pCmdApi->print)(cmdIoParam, " %d : %d : %d"LINE_TERM,	RTC_Bcd2ToByte(SMB_StatusObj.currentTime.Hours), RTC_Bcd2ToByte(SMB_StatusObj.currentTime.Minutes),	RTC_Bcd2ToByte(SMB_StatusObj.currentTime.Seconds));
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM);
	return;
}

static void smb_cmd_rtc_setdate (SYS_CMD_DEVICE_NODE *pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	uint8_t Year, Month, Date, WeekDay;

	if (argc < 5) {
		(*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage : setdate 21 11 22 1 (2021/11/22 Monday) \r\n");
		return;
	}

	Year = (uint8_t)strtoul (argv[1], NULL, 10);
	Month = (uint8_t)strtoul (argv[2], NULL, 10);
	Date = (uint8_t)strtoul (argv[3], NULL, 10);
	WeekDay = (uint8_t)strtoul (argv[4], NULL, 10);

	if (Year > 99) {
		(*pCmdIO->pCmdApi->msg)(cmdIoParam, "0 < year < 99 \r\n");
		return;
	}

	if (Month > 12) {
		(*pCmdIO->pCmdApi->msg)(cmdIoParam, "0 < month < 13 \r\n");
		return;
	}

	if (Date > 31) {
		(*pCmdIO->pCmdApi->msg)(cmdIoParam, "0 < date < 32 \r\n");
		return;
	}

	if (WeekDay > 7) {
		(*pCmdIO->pCmdApi->msg)(cmdIoParam, "0 < WeekDay < 8 \r\n");
		return;
	}

	RTC_DateTypeDef sDate;
	sDate.Year = RTC_ByteToBcd2(Year);
	sDate.Month = RTC_ByteToBcd2(Month);
	sDate.Date = RTC_ByteToBcd2(Date);
	sDate.WeekDay = RTC_ByteToBcd2(WeekDay);

	assert (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) == HAL_OK);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, " %s() is DONE"LINE_TERM, __FUNCTION__);

	return;
}

static void smb_cmd_rtc_settime (SYS_CMD_DEVICE_NODE *pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	RTC_TimeTypeDef sTime;
	uint8_t Hours, Minutes, Seconds;

	if (argc != 4) {
		(*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage : settime hour min sec \r\n");
		return;
	}

	Hours = (uint8_t)strtoul (argv[1], NULL, 0);
	Minutes = (uint8_t)strtoul (argv[2], NULL, 0);
	Seconds = (uint8_t)strtoul (argv[3], NULL, 0);

	sTime.Hours = RTC_ByteToBcd2(Hours);
	sTime.Minutes = RTC_ByteToBcd2(Minutes);
	sTime.Seconds = RTC_ByteToBcd2(Seconds);
	sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
	sTime.StoreOperation = RTC_STOREOPERATION_RESET;

	assert (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) == HAL_OK);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, " %s() is DONE"LINE_TERM, __FUNCTION__);

	return;
}

static void smb_cmd_showuptime (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	uint8_t day, hour, min, sec;
	uint64_t tmp;

	tmp = SMB_StatusObj.uptime_counter;

	day = tmp /DAY_TO_SEC;
	tmp = tmp - (day*DAY_TO_SEC);

	hour = tmp/HOUR_TO_SEC;
	tmp = tmp - (hour*HOUR_TO_SEC);

	min = tmp/MIN_TO_SEC;
	tmp = tmp - (min*MIN_TO_SEC);

	sec = tmp;

	(*pCmdIO->pCmdApi->print)(cmdIoParam, " Uptime = %d days, %d hours, %d mins, %d sec \r\n", day, hour, min, sec);

	return;
}

static void smb_cmd_boot_cause (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	if (__HAL_RCC_GET_FLAG(RCC_FLAG_FWRST)) (*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, "RCC_FLAG_FWRST : Firewall reset flag"LINE_TERM);
	if (__HAL_RCC_GET_FLAG(RCC_FLAG_OBLRST)) (*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, "RCC_FLAG_OBLRST : Option Byte Loader reset flag"LINE_TERM);
	if (__HAL_RCC_GET_FLAG(RCC_FLAG_PINRST)) (*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, "RCC_FLAG_PINRST : PIN reset flag"LINE_TERM);
	if (__HAL_RCC_GET_FLAG(RCC_FLAG_BORRST)) (*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, "RCC_FLAG_BORRST : BOR reset flag"LINE_TERM);
	if (__HAL_RCC_GET_FLAG(RCC_FLAG_SFTRST)) (*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, "RCC_FLAG_SFTRST : Software Reset flag"LINE_TERM);
	if (__HAL_RCC_GET_FLAG(RCC_FLAG_IWDGRST)) (*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, "RCC_FLAG_IWDGRST : Independent Watchdog reset flag"LINE_TERM);
	if (__HAL_RCC_GET_FLAG(RCC_FLAG_WWDGRST)) (*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, "RCC_FLAG_WWDGRST : Window watchdog reset flag"LINE_TERM);
	if (__HAL_RCC_GET_FLAG(RCC_FLAG_LPWRRST)) (*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, "RCC_FLAG_LPWRRST : Low-Power reset flag"LINE_TERM);
}

static void smb_cmd_boot_cause_clear (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	__HAL_RCC_CLEAR_RESET_FLAGS();
}

static void smb_cmd_show_scb (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	uint32_t ACTLR, CPUID, ICSR, VTOR, AIRCR, SCR, CCR, SHCSR, CFSR, HFSR, BFAR, AFSR;

	ACTLR = READ_REG(SCnSCB->ACTLR);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "ACTLR=%#010"PRIx32 LINE_TERM, ACTLR);

	CPUID = READ_REG(SCB->CPUID);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "CPUID=%#010"PRIx32 LINE_TERM, CPUID);

	ICSR = READ_REG(SCB->ICSR);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "ICSR=%#010"PRIx32 LINE_TERM, ICSR);

	VTOR = READ_REG(SCB->VTOR);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "VTOR=%#010"PRIx32 LINE_TERM, VTOR);

	AIRCR = READ_REG(SCB->AIRCR);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "AIRCR=%#010"PRIx32 LINE_TERM, AIRCR);

	SCR = READ_REG(SCB->SCR);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "SCR=%#010"PRIx32 LINE_TERM, SCR);

	CCR = READ_REG(SCB->CCR);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "CCR=%#010"PRIx32 LINE_TERM, CCR);

	SHCSR = READ_REG(SCB->SHCSR);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "SHCSR=%#010"PRIx32 LINE_TERM, SHCSR);

	CFSR = READ_REG(SCB->CFSR);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "CFSR=%#010"PRIx32 LINE_TERM, CFSR);

	HFSR = READ_REG(SCB->HFSR);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "HFSR=%#010"PRIx32 LINE_TERM, HFSR);

	BFAR = READ_REG(SCB->BFAR);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "BFAR=%#010"PRIx32 LINE_TERM, BFAR);

	AFSR = READ_REG(SCB->AFSR);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "AFSR=%#010"PRIx32 LINE_TERM, AFSR);

	return;
}

typedef struct {
	uint32_t irq_no;
	char irq_name[30];
} irq_no_name_t;

static irq_no_name_t irq_no_name[DMA2D_IRQn+1] = {
		{WWDG_IRQn, "WWDG_IRQn"},
		{PVD_PVM_IRQn, "PVD_PVM_IRQn"},
		{TAMP_STAMP_IRQn, "TAMP_STAMP_IRQn"},
		{RTC_WKUP_IRQn, "RTC_WKUP_IRQn"},
		{FLASH_IRQn, "FLASH_IRQn"},
		{RCC_IRQn, "RCC_IRQn"},
		{EXTI0_IRQn, "EXTI0_IRQn"},
		{EXTI1_IRQn, "EXTI1_IRQn"},
		{EXTI2_IRQn, "EXTI2_IRQn"},
		{EXTI3_IRQn, "EXTI3_IRQn"},
		{EXTI4_IRQn, "EXTI4_IRQn"},	//10
		{DMA1_Channel1_IRQn, "DMA1_Channel1_IRQn"},
		{DMA1_Channel2_IRQn, "DMA1_Channel2_IRQn"},
		{DMA1_Channel3_IRQn, "DMA1_Channel3_IRQn"},
		{DMA1_Channel4_IRQn, "DMA1_Channel4_IRQn"},
		{DMA1_Channel5_IRQn, "DMA1_Channel5_IRQn"},
		{DMA1_Channel6_IRQn, "DMA1_Channel6_IRQn"},
		{DMA1_Channel7_IRQn, "DMA1_Channel7_IRQn"},
		{ADC1_2_IRQn, "ADC1_2_IRQn"},
		{CAN1_TX_IRQn, "CAN1_TX_IRQn"},
		{CAN1_RX0_IRQn, "CAN1_RX0_IRQn"},	//20
		{CAN1_RX1_IRQn, "CAN1_RX1_IRQn"},
		{CAN1_SCE_IRQn, "CAN1_SCE_IRQn"},
		{EXTI9_5_IRQn, "EXTI9_5_IRQn"},
		{TIM1_BRK_TIM15_IRQn, "TIM1_BRK_TIM15_IRQn"},
		{TIM1_UP_TIM16_IRQn, "TIM1_UP_TIM16_IRQn"},
		{TIM1_TRG_COM_TIM17_IRQn, "TIM1_TRG_COM_TIM17_IRQn"},
		{TIM1_CC_IRQn, "TIM1_CC_IRQn"},
		{TIM2_IRQn, "TIM2_IRQn"},
		{TIM3_IRQn, "TIM3_IRQn"},
		{TIM4_IRQn, "TIM4_IRQn"},		//30
		{I2C1_EV_IRQn, "I2C1_EV_IRQn"},
		{I2C1_ER_IRQn, "I2C1_ER_IRQn"},
		{I2C2_EV_IRQn, "I2C2_EV_IRQn"},
		{I2C2_ER_IRQn, "I2C2_ER_IRQn"},
		{SPI1_IRQn, "SPI1_IRQn"},
		{SPI2_IRQn, "SPI2_IRQn"},
		{USART1_IRQn, "USART1_IRQn"},
		{USART2_IRQn, "USART2_IRQn"},
		{USART3_IRQn, "USART3_IRQn"},
		{EXTI15_10_IRQn, "EXTI15_10_IRQn"},		//40
		{RTC_Alarm_IRQn, "RTC_Alarm_IRQn"},
		{DFSDM1_FLT3_IRQn, "DFSDM1_FLT3_IRQn"},
		{TIM8_BRK_IRQn, "TIM8_BRK_IRQn"},
		{TIM8_UP_IRQn, "TIM8_UP_IRQn"},
		{TIM8_TRG_COM_IRQn, "TIM8_TRG_COM_IRQn"},
		{TIM8_CC_IRQn, "TIM8_CC_IRQn"},
		{ADC3_IRQn, "ADC3_IRQn"},
		{FMC_IRQn, "FMC_IRQn"},
		{SDMMC1_IRQn, "SDMMC1_IRQn"},
		{TIM5_IRQn, "TIM5_IRQn"},	// 50
		{SPI3_IRQn, "SPI3_IRQn"},
		{UART4_IRQn, "UART4_IRQn"},
		{UART5_IRQn, "UART5_IRQn"},
		{TIM6_DAC_IRQn, "TIM6_DAC_IRQn"},
		{TIM7_IRQn, "TIM7_IRQn"},
		{DMA2_Channel1_IRQn, "DMA2_Channel1_IRQn"},
		{DMA2_Channel2_IRQn, "DMA2_Channel2_IRQn"},
		{DMA2_Channel3_IRQn, "DMA2_Channel3_IRQn"},
		{DMA2_Channel4_IRQn, "DMA2_Channel4_IRQn"},
		{DMA2_Channel5_IRQn, "DMA2_Channel5_IRQn"},	// 60
		{DFSDM1_FLT0_IRQn, "DFSDM1_FLT0_IRQn"},
		{DFSDM1_FLT1_IRQn, "DFSDM1_FLT1_IRQn"},
		{DFSDM1_FLT2_IRQn, "DFSDM1_FLT2_IRQn"},
		{COMP_IRQn, "COMP_IRQn"},
		{LPTIM1_IRQn, "LPTIM1_IRQn"},
		{LPTIM2_IRQn, "LPTIM2_IRQn"},
		{OTG_FS_IRQn, "OTG_FS_IRQn"},
		{DMA2_Channel6_IRQn, "DMA2_Channel6_IRQn"},
		{DMA2_Channel7_IRQn, "DMA2_Channel7_IRQn"},
		{LPUART1_IRQn, "LPUART1_IRQn"},		// 70
		{QUADSPI_IRQn, "QUADSPI_IRQn"},
		{I2C3_EV_IRQn, "I2C3_EV_IRQn"},
		{I2C3_ER_IRQn, "I2C3_ER_IRQn"},
		{SAI1_IRQn, "SAI1_IRQn"},
		{SAI2_IRQn, "SAI2_IRQn"},
		{SWPMI1_IRQn, "SWPMI1_IRQn"},
		{TSC_IRQn, "TSC_IRQn"},
		{LCD_IRQn, "LCD_IRQn"},
		{79, "79"},
		{RNG_IRQn, "RNG_IRQn"},		// 80
		{FPU_IRQn, "FPU_IRQn"},
		{CRS_IRQn, "CRS_IRQn"},
		{I2C4_EV_IRQn, "I2C4_EV_IRQn"},
		{I2C4_ER_IRQn, "I2C4_ER_IRQn"},
		{DCMI_IRQn, "DCMI_IRQn"},
		{CAN2_TX_IRQn, "CAN2_TX_IRQn"},
		{CAN2_RX0_IRQn, "CAN2_RX0_IRQn"},
		{CAN2_RX1_IRQn, "CAN2_RX1_IRQn"},
		{CAN2_SCE_IRQn, "CAN2_SCE_IRQn"},
		{DMA2D_IRQn, "DMA2D_IRQn"},
};

#if 0
typedef struct
{
	__IOM uint32_t ISER[8U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
	uint32_t RESERVED0[24U];
	__IOM uint32_t ICER[8U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
	uint32_t RESERVED1[24U];
	__IOM uint32_t ISPR[8U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
	uint32_t RESERVED2[24U];
	__IOM uint32_t ICPR[8U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
	uint32_t RESERVED3[24U];
	__IOM uint32_t IABR[8U];               /*!< Offset: 0x200 (R/W)  Interrupt Active bit Register */
	uint32_t RESERVED4[56U];
	__IOM uint8_t  IP[240U];               /*!< Offset: 0x300 (R/W)  Interrupt Priority Register (8Bit wide) */
	uint32_t RESERVED5[644U];
	__OM  uint32_t STIR;                   /*!< Offset: 0xE00 ( /W)  Software Trigger Interrupt Register */
}  NVIC_Type;
#endif

static void smb_cmd_show_nvic (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	uint32_t ISERn, ICERn, ISPRn, ICPRn, IABRn, STIR;

	for (uint32_t i = 0 ; i < 8 ; i++) {
		ISERn = READ_REG(NVIC->ISER[i]);
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "ISER[%d]=%#010"PRIx32 LINE_TERM, i, ISERn);
	}

	for (uint32_t i = 0 ; i < 8 ; i++) {
		ICERn = READ_REG(NVIC->ICER[i]);
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "ICER[%d]=%#010"PRIx32 LINE_TERM, i, ICERn);
	}

	for (uint32_t i = 0 ; i < 8 ; i++) {
		ISPRn = READ_REG(NVIC->ISPR[i]);
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "ISPR[%d]=%#010"PRIx32 LINE_TERM, i, ISPRn);
	}

	for (uint32_t i = 0 ; i < 8 ; i++) {
		ICPRn = READ_REG(NVIC->ICPR[i]);
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "ICPR[%d]=%#010"PRIx32 LINE_TERM, i, ICPRn);
	}

	for (uint32_t i = 0 ; i < 8 ; i++) {
		IABRn = READ_REG(NVIC->IABR[i]);
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "IABR[%d]=%#010"PRIx32 LINE_TERM, i, IABRn);
	}

#if 0
	uint32_t IPn;
	for (uint32_t i = 0 ; i < 240 ; i++) {
		IPn = READ_REG(NVIC->IP[i]);
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "IP[%3d]=%#010"PRIx32 LINE_TERM, i, IPn);
	}
#endif

	STIR = READ_REG(NVIC->STIR);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "STIR=%#010"PRIx32 LINE_TERM, STIR);

	//	HAL_NVIC_GetActive() 를 사용해서 각 intr 이 개별적으로 enalbe 되어 있는지 표시할 것..

	ISERn = READ_REG(NVIC->ISER[0]);
	for (uint32_t irq_no = WWDG_IRQn ; irq_no < I2C1_ER_IRQn ; irq_no++) {
		if ((ISERn & (1 << irq_no)) != 0) {
			(*pCmdIO->pCmdApi->print)(cmdIoParam, "irq_no %2d (%s) is Enabled"LINE_TERM, irq_no, irq_no_name[irq_no].irq_name);
		}
	}

	ISERn = READ_REG(NVIC->ISER[1]);
	for (uint32_t irq_no = I2C1_ER_IRQn ; irq_no < COMP_IRQn ; irq_no++) {
		if ((ISERn & (1 << (irq_no-32))) != 0) {
			(*pCmdIO->pCmdApi->print)(cmdIoParam, "irq_no %2d (%s) is Enabled"LINE_TERM, irq_no, irq_no_name[irq_no].irq_name);
		}
	}

	ISERn = READ_REG(NVIC->ISER[2]);
	for (uint32_t irq_no = COMP_IRQn ; irq_no < DMA2D_IRQn+1 ; irq_no++) {
		if ((ISERn & (1 << (irq_no-64))) != 0) {
			(*pCmdIO->pCmdApi->print)(cmdIoParam, "irq_no %2d (%s) is Enabled"LINE_TERM, irq_no, irq_no_name[irq_no].irq_name);
		}
	}

	return;
}

static void smb_cmd_show_exti (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	uint32_t exticr1, exticr2, exticr3, exticr4;
	exticr1 = READ_REG(SYSCFG->EXTICR[0]);
	exticr2 = READ_REG(SYSCFG->EXTICR[1]);
	exticr3 = READ_REG(SYSCFG->EXTICR[2]);
	exticr4 = READ_REG(SYSCFG->EXTICR[3]);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "exticr1=%#010"PRIx32 LINE_TERM, exticr1);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "exticr2=%#010"PRIx32 LINE_TERM, exticr2);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "exticr3=%#010"PRIx32 LINE_TERM, exticr3);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "exticr4=%#010"PRIx32 LINE_TERM, exticr4);

	return;
}


static void smb_cmd_set_exti (SYS_CMD_DEVICE_NODE *pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	uint32_t exti_no;
	EXTI_HandleTypeDef exti_handle;

	if (argc != 2) {
		(*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage : setexti exti_no (0 ~ 15)"LINE_TERM);
		return;
	}

	exti_no = strtoul (argv[1], NULL, 0);

	if (exti_no > 15) {
		(*pCmdIO->pCmdApi->msg)(cmdIoParam, "Usage : setexti exti_no (0 ~ 15)"LINE_TERM);
		return;
	}

#if 0
#define EXTI_LINE_0                         (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x00u)
#define EXTI_LINE_1                         (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x01u)
#define EXTI_LINE_2                         (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x02u)
#define EXTI_LINE_3                         (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x03u)
#define EXTI_LINE_4                         (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x04u)
#define EXTI_LINE_5                         (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x05u)
#define EXTI_LINE_6                         (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x06u)
#define EXTI_LINE_7                         (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x07u)
#define EXTI_LINE_8                         (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x08u)
#define EXTI_LINE_9                         (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x09u)
#define EXTI_LINE_10                        (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x0Au)
#define EXTI_LINE_11                        (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x0Bu)
#define EXTI_LINE_12                        (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x0Cu)
#define EXTI_LINE_13                        (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x0Du)
#define EXTI_LINE_14                        (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x0Eu)
#define EXTI_LINE_15                        (EXTI_GPIO     | EXTI_REG1 | EXTI_EVENT | 0x0Fu)
#endif

	(*pCmdIO->pCmdApi->print)(cmdIoParam, "Let EXTI_LINE_%d happen"LINE_TERM, exti_no);

	switch (exti_no) {
	case 0 : exti_handle.Line = EXTI_LINE_0; break;
	case 1 : exti_handle.Line = EXTI_LINE_1; break;
	case 2 : exti_handle.Line = EXTI_LINE_2; break;
	case 3 : exti_handle.Line = EXTI_LINE_3; break;
	case 4 : exti_handle.Line = EXTI_LINE_4; break;
	case 5 : exti_handle.Line = EXTI_LINE_5; break;
	case 6 : exti_handle.Line = EXTI_LINE_6; break;
	case 7 : exti_handle.Line = EXTI_LINE_7; break;
	case 8 : exti_handle.Line = EXTI_LINE_8; break;
	case 9 : exti_handle.Line = EXTI_LINE_9; break;
	case 10 : exti_handle.Line = EXTI_LINE_10; break;
	case 11 : exti_handle.Line = EXTI_LINE_11; break;
	case 12 : exti_handle.Line = EXTI_LINE_12; break;
	case 13 : exti_handle.Line = EXTI_LINE_13; break;
	case 14 : exti_handle.Line = EXTI_LINE_14; break;
	case 15 : exti_handle.Line = EXTI_LINE_15; break;
	default : assert (0 == 1); return; break;
	}

	HAL_EXTI_GenerateSWI(&exti_handle);
}

static void smb_cmd_show_intr (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 1) goto USAGE;

	(*pCmdIO->pCmdApi->print)(cmdIoParam, "RCC_Intr_count = %d"LINE_TERM, SMB_IntrObj.RCC_Intr_count);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "DMA1_Chan_1_count = %d"LINE_TERM, SMB_IntrObj.DMA1_Chan_1_count);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "DMA1_Chan_3_count = %d"LINE_TERM, SMB_IntrObj.DMA1_Chan_3_count);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "DMA1_Chan_4_count = %d"LINE_TERM, SMB_IntrObj.DMA1_Chan_4_count);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "DMA1_Chan_6_count = %d"LINE_TERM, SMB_IntrObj.DMA1_Chan_6_count);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "DMA1_Chan_7_count = %d"LINE_TERM, SMB_IntrObj.DMA1_Chan_7_count);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "ADC1_2_count = %d"LINE_TERM,SMB_IntrObj. ADC1_2_count);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "EXTI9_5_count = %d"LINE_TERM, SMB_IntrObj.EXTI9_5_count);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "TIM1_UP_16_count = %d"LINE_TERM, SMB_IntrObj.TIM1_UP_16_count);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "TIM4_count = %d"LINE_TERM, SMB_IntrObj.TIM4_count);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "SPI1_count = %d"LINE_TERM, SMB_IntrObj.SPI1_count);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "USART1_count = %d"LINE_TERM, SMB_IntrObj.USART1_count);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "USART2_count = %d"LINE_TERM, SMB_IntrObj.USART2_count);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "USART3_count = %d"LINE_TERM, SMB_IntrObj.USART3_count);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "EXTI15_10_count = %d"LINE_TERM, SMB_IntrObj.EXTI15_10_count);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "USART4_count = %d"LINE_TERM, SMB_IntrObj.USART4_count);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "DMA2_Chan_3_count = %d"LINE_TERM, SMB_IntrObj.DMA2_Chan_3_count);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "DMA2_Chan_5_count = %d"LINE_TERM, SMB_IntrObj.DMA2_Chan_5_count);

	return;

	USAGE :
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "USAGE : showintr"LINE_TERM);
	return;
}

static const SYS_CMD_DESCRIPTOR    System_CommandTbl []=
{
		// system command..
		{"clear",       	smb_cmd_clearScreen,		"\t\t- clear screen"},
		{"c",       		smb_cmd_clearScreen,		"\t\t- clear screen"},
		{"showsystem",    	smb_cmd_show_system,		"\t\t- showsystem"},
		{"taskinfo",		smb_cmd_taskinfo,			"\t\t- taskinfo"},

		// Time/RTC control
		{"showtime", 		smb_cmd_rtc_showtime,		"\t\t- showtime"},
		{"setdate",			smb_cmd_rtc_setdate,  		"\t\t- setdate 21 11 22 1 (2021/11/22 Monday)"},
		{"settime",			smb_cmd_rtc_settime,  		"\t\t- settime hour min sec"},
		{"uptime",     		smb_cmd_showuptime,      	"\t\t- uptime"},
		{"runtime",     	smb_cmd_showuptime,      	"\t\t- runtime"},

		// MCU control..
		{"bootcause",    	smb_cmd_boot_cause,			"\t\t- bootcause : read RCC CSR"},
		{"bootclear", 		smb_cmd_boot_cause_clear,	"\t\t- bootclear : clear RCC CSR"},
		{"showscb",    		smb_cmd_show_scb,       	"\t\t- showscb"},
		{"shownvic",    	smb_cmd_show_nvic,       	"\t\t- shownvic"},
		{"showexti",    	smb_cmd_show_exti,       	"\t\t- showexti"},
		{"setexti",    		smb_cmd_set_exti,       	"\t\t- setexti"},
		{"showintr",    	smb_cmd_show_intr,       	"\t\t- showintr"},
};

bool smb_cmd_system_add ()
{
	assert (SYS_CMD_ADDGRP(System_CommandTbl, sizeof(System_CommandTbl)/sizeof(*System_CommandTbl), "system", ": system command group") == true);
	return true;
}



