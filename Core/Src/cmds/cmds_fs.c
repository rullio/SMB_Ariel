/**
 ******************************************************************************
 * File Name          : cmds_fs.c
 * Description        : This file is generated by 위대한 송 인재.
 ******************************************************************************
 *
 * COPYRIGHT(c) 2024 LMS Co. Ltd.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *   1. Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *   3. Neither the name of STMicroelectronics nor the names of its contributors
 *      may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************
 */

#include "main.h"

extern bool	IsFS_mount;

static void smb_cmd_fsshow (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (IsFS_mount != true) {
		(*pCmdIO->pCmdApi->msg)(cmdIoParam, "File system mount first"LINE_TERM);
		return;
	}

	if (argc != 1) {
		goto USAGE;
		return;
	}

	(*pCmdIO->pCmdApi->print)(cmdIoParam, "fs size   : %ld KB"LINE_TERM, fsGetSize()/1024);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "fs free   : %ld KB"LINE_TERM, fsGetFree() / 1024);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "fs used   : %ld KB"LINE_TERM, (fsGetSize() - fsGetFree()) / 1024);

#if 0
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.rcache.block = %ld"LINE_TERM, lfs.rcache.block);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.rcache.off = %ld"LINE_TERM, lfs.rcache.off);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.rcache.size = %ld"LINE_TERM, lfs.rcache.size);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.rcache.buffer = 0x%lx"LINE_TERM, lfs.rcache.buffer);

	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.pcache.block = %ld"LINE_TERM, lfs.pcache.block);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.pcache.off = %ld"LINE_TERM, lfs.pcache.off);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.pcache.size = %ld"LINE_TERM, lfs.pcache.size);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.pcache.buffer = 0x%lx"LINE_TERM, lfs.pcache.buffer);

	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.root[0] = %ld"LINE_TERM, lfs.root[0]);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.root[1] = %ld"LINE_TERM, lfs.root[1]);

	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.gstate.tag = %ld"LINE_TERM, lfs.gstate.tag);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.gstate.gstate.pair[0] = %ld"LINE_TERM, lfs.gstate.pair[0]);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.gstate.gstate.pair[1] = %ld"LINE_TERM, lfs.gstate.pair[1]);

	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.gdisk.tag = %ld"LINE_TERM, lfs.gdisk.tag);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.gdisk.gstate.pair[0] = %ld"LINE_TERM, lfs.gdisk.pair[0]);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.gdisk.gstate.pair[1] = %ld"LINE_TERM, lfs.gdisk.pair[1]);

	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.gdelta.tag = %ld"LINE_TERM, lfs.gdelta.tag);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.gdelta.gstate.pair[0] = %ld"LINE_TERM, lfs.gdelta.pair[0]);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.gdelta.gstate.pair[1] = %ld"LINE_TERM, lfs.gdelta.pair[1]);

	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.lookahead.start = %ld"LINE_TERM, lfs.lookahead.start);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.lookahead.size = %ld"LINE_TERM, lfs.lookahead.size);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.lookahead.next = %ld"LINE_TERM, lfs.lookahead.next);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.lookahead.ckpoint = %ld"LINE_TERM, lfs.lookahead.ckpoint);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.lookahead.buffer = 0x%lx"LINE_TERM, lfs.lookahead.buffer);

	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.cfg->context = %ld"LINE_TERM, lfs.cfg->context);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.cfg->read_size = %ld"LINE_TERM, lfs.cfg->read_size);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.cfg->prog_size = %ld"LINE_TERM, lfs.cfg->prog_size);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.cfg->block_size = %ld"LINE_TERM, lfs.cfg->block_size);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.cfg->block_count = %ld"LINE_TERM, lfs.cfg->block_count);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.cfg->block_cycles = %ld"LINE_TERM, lfs.cfg->block_cycles);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.cfg->cache_size = %ld"LINE_TERM, lfs.cfg->cache_size);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.cfg->lookahead_size = %ld"LINE_TERM, lfs.cfg->lookahead_size);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.cfg->compact_thresh = %ld"LINE_TERM, lfs.cfg->compact_thresh);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.cfg->name_max = %ld"LINE_TERM, lfs.cfg->name_max);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.cfg->file_max = %ld"LINE_TERM, lfs.cfg->file_max);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.cfg->attr_max = %ld"LINE_TERM, lfs.cfg->attr_max);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.cfg->metadata_max = %ld"LINE_TERM, lfs.cfg->metadata_max);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.cfg->inline_max = %ld"LINE_TERM, lfs.cfg->inline_max);

	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.block_count = %ld"LINE_TERM, lfs.block_count);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.name_max = %ld"LINE_TERM, lfs.name_max);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.file_max = 0x%lx"LINE_TERM, lfs.file_max);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.attr_max = %ld"LINE_TERM, lfs.attr_max);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.inline_max = %ld"LINE_TERM, lfs.inline_max);

#else
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.rcache.size = %ld"LINE_TERM, lfs.rcache.size);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.pcache.size = %ld"LINE_TERM, lfs.pcache.size);

	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.cfg->context = %ld"LINE_TERM, lfs.cfg->context);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.cfg->read_size = %ld"LINE_TERM, lfs.cfg->read_size);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.cfg->prog_size = %ld"LINE_TERM, lfs.cfg->prog_size);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.cfg->block_size = %ld"LINE_TERM, lfs.cfg->block_size);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.cfg->block_count = %ld"LINE_TERM, lfs.cfg->block_count);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.cfg->block_cycles = %ld"LINE_TERM, lfs.cfg->block_cycles);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.cfg->cache_size = %ld"LINE_TERM, lfs.cfg->cache_size);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lfs.cfg->lookahead_size = %ld"LINE_TERM, lfs.cfg->lookahead_size);
#endif

	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "fsshow"LINE_TERM);
	return;
}

static void smb_cmd_fsls (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	lfs_dir_t dir;
	struct lfs_info info;
	char path[LFS_NAME_MAX];
	uint32_t file_count;

	assert (IsFS_mount == true);

	if (argc == 1) strcpy (path, ".");
	else if (argc == 2) strcpy (path, argv[1]);
	else goto USAGE;


	if (lfs_dir_open(&lfs, &dir, path) != LFS_ERR_OK){
		(*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM"No such directory : %s"LINE_TERM, path);
		return;
	}
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, LINE_TERM"dir/file\tsize\tname");
	// find index, +2 for . and ..
	for (file_count = 0 ; ; file_count++) {
		int res = lfs_dir_read(&lfs, &dir, &info);
		if (res != true) break;
		(*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM"%s\t%12d\t%s", (info.type == LFS_TYPE_DIR)?"DIR":"FILE", info.size, info.name);
	}
	(*pCmdIO->pCmdApi->print)(cmdIoParam, LINE_TERM"Total file_count = %d"LINE_TERM, file_count);
	assert (lfs_dir_close(&lfs, &dir) == LFS_ERR_OK);

	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "ls"LINE_TERM);
	return;
}

static void smb_cmd_fsmkfile (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	lfs_file_t file;
	char path[LFS_NAME_MAX];
	lfs_size_t file_size = 0;
	char c = 0;

	assert (IsFS_mount == true);

	if (argc == 1) goto USAGE;

	if (argc == 2) {
		strcpy(path, argv[1]);
	}
	else if (argc == 3) {
		strcpy(path, argv[1]);
		file_size = strtoul(argv[2], NULL, 0);
	}
	else if (argc == 4) {
		strcpy(path, argv[1]);
		file_size = strtoul(argv[2], NULL, 0);
		c = (char)strtoul(argv[3], NULL, 0);
	}
	else {
		goto USAGE;
	}

	assert (lfs_file_open(&lfs, &file, path, LFS_O_RDWR | LFS_O_CREAT) == LFS_ERR_OK);

	for (uint32_t i = 0 ; i < file_size ; i++) {
		lfs_file_write(&lfs, &file, &c, 1);
	}

	assert (lfs_file_close(&lfs, &file) == LFS_ERR_OK);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "mkfile (sample.txt size value)"LINE_TERM);
	return;
}

static void smb_cmd_fsdelfile (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	struct lfs_info info;
	char path[LFS_NAME_MAX];

	assert (IsFS_mount == true);
	if (argc != 2) goto USAGE;

	strcpy (path, argv[1]);

	if (lfs_stat(&lfs, path, &info) != LFS_ERR_OK) {
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "No such file or directory, %s"LINE_TERM, path);
		return;
	}

	if (info.type == LFS_TYPE_DIR) {
		lfs_dir_t dir;
		assert (lfs_dir_open(&lfs, &dir, argv[1]) >= 0);
		if (dir.m.count != 0) {
			(*pCmdIO->pCmdApi->print)(cmdIoParam, "The directory %s has %d files. Remove them first."LINE_TERM, argv[1], dir.m.count);
			lfs_dir_close(&lfs, &dir);
			return;
		}
		lfs_dir_close(&lfs, &dir);	// directory 는 close 된 상태에서 지워야 하기 때문에 여기서 close 해준다.
	}

	assert (lfs_remove(&lfs, argv[1]) == LFS_ERR_OK);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "del file or directory name (directory should be empty)"LINE_TERM);
	return;
}

static void smb_cmd_fsdelallfile (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	struct lfs_info info;
	char path[LFS_NAME_MAX];
	lfs_dir_t dir;

	assert (IsFS_mount == true);
	if (argc != 1) goto USAGE;

	strcpy (path, ".");

	assert (lfs_dir_open(&lfs, &dir, path) == LFS_ERR_OK);

	while (1) {
		int res = lfs_dir_read(&lfs, &dir, &info);
		if (res != true) break;
		if (info.type == LFS_TYPE_REG) {	// file 만 삭제
			if (!strcmp (info.name, CONFIG_FILE_NAME)) continue;	// config 파일은 삭제하지 말 것.
			assert (lfs_remove(&lfs, info.name) == LFS_ERR_OK);
		}
	}

	assert (lfs_dir_close(&lfs, &dir) == LFS_ERR_OK);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "del file or directory name (directory should be empty)"LINE_TERM);
	return;
}

static void smb_cmd_fscpfile (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	lfs_file_t src_file, dest_file;
	char src_path[LFS_NAME_MAX], dest_path[LFS_NAME_MAX];
	struct lfs_info info;
	lfs_size_t file_size;
	void *buffer = NULL;

	assert (IsFS_mount == true);
	if (argc != 3) goto USAGE;

	strcpy(src_path, argv[1]);
	strcpy(dest_path, argv[2]);

	if (lfs_stat(&lfs, src_path, &info) != LFS_ERR_OK) {
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "No such file %s"LINE_TERM, src_path);
		return;
	}

	file_size = info.size;
	buffer = malloc (file_size);
	assert (buffer != NULL);
	memset (buffer, 0, file_size);

	assert (lfs_file_open(&lfs, &src_file, src_path, LFS_O_RDONLY) == LFS_ERR_OK);
	assert (lfs_file_read(&lfs, &src_file, buffer, file_size) == file_size);
	assert (lfs_file_close(&lfs, &src_file) == LFS_ERR_OK);

	assert (lfs_file_open(&lfs, &dest_file, dest_path, LFS_O_RDWR | LFS_O_CREAT) == LFS_ERR_OK);
	assert (lfs_file_write(&lfs, &dest_file, buffer, file_size) == file_size);
	assert (lfs_file_close(&lfs, &dest_file) == LFS_ERR_OK);
	free(buffer);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "cp src_file_name dest_file_name"LINE_TERM);
	return;
}

static void smb_cmd_fscatfile (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	lfs_file_t file;
	char path[LFS_NAME_MAX];
	struct lfs_info info;
	lfs_size_t file_size;
	void *buffer = NULL;

	assert (IsFS_mount == true);
	if (argc != 2) goto USAGE;

	strcpy(path, argv[1]);

	if (lfs_stat(&lfs, path, &info) != LFS_ERR_OK) {
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "No such file %s"LINE_TERM, path);
		return;
	}

	file_size = info.size;

	if (file_size > 2048) {
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "The file %s is %d Byte. Let me show 2KB only"LINE_TERM LINE_TERM, path);
		file_size = 2048;
	}
	buffer = malloc (file_size);
	assert (buffer != NULL);
	memset (buffer, 0, file_size);

	assert (lfs_file_open(&lfs, &file, path, LFS_O_RDONLY) == LFS_ERR_OK);
	assert (lfs_file_read(&lfs, &file, buffer, file_size) == file_size);
	assert (lfs_file_close(&lfs, &file) == LFS_ERR_OK);

	hexDump (pCmdIO, 0, buffer, file_size);
	HAL_Delay(file_size/10);	// print 하는 속도가 대략 1ms 에 10 글자를 찍으므로 대충 이 정도 delay 를 줌.
	free(buffer);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "cat src_file_name"LINE_TERM);
	return;
}

static void smb_cmd_fs_df (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	int total_size, free_size;

	if (argc != 1) goto USAGE;

	assert (IsFS_mount == true);

	total_size = fsGetSize();
	free_size = fsGetFree();

	(*pCmdIO->pCmdApi->print)(cmdIoParam, "fs size   : %ld KB"LINE_TERM, total_size/1024);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "fs free   : %ld KB"LINE_TERM, free_size / 1024);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "fs used   : %ld KB (%ld%% Used)"LINE_TERM, (total_size - free_size) / 1024, ((total_size - free_size)*100/total_size));
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "free"LINE_TERM);
	return;
}

static void smb_cmd_fs_append (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	lfs_file_t file;
	struct lfs_info info;

	assert (IsFS_mount == true);
	if (argc < 2) goto USAGE;

	if (lfs_stat(&lfs, FW_UPGRADE_HISTORY_FILE, &info) == LFS_ERR_OK) assert (lfs_file_open(&lfs, &file, FW_UPGRADE_HISTORY_FILE, LFS_O_WRONLY | LFS_O_APPEND) == LFS_ERR_OK);
	else assert (lfs_file_open(&lfs, &file, FW_UPGRADE_HISTORY_FILE, LFS_O_WRONLY | LFS_O_CREAT | LFS_O_APPEND) == LFS_ERR_OK);

	for (uint32_t i = 1 ; i < argc ; i++) {
		lfs_file_write(&lfs, &file, argv[i], strlen(argv[i]));
	}
	lfs_file_write(&lfs, &file, LINE_TERM, 2);
	assert (lfs_file_close(&lfs, &file) == LFS_ERR_OK);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "append \"bla bla bla\""LINE_TERM);
	return;
}

static void smb_cmd_fs_trunc (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	char path[LFS_NAME_MAX];
	lfs_file_t file;
	int err;
	uint32_t offset;

	assert (IsFS_mount == true);
	if (argc != 3) goto USAGE;

	strcpy(path, argv[1]);
	offset = strtoul(argv[2], NULL, 0);

	if (fsIsDir(path) == true) {
		(*pCmdIO->pCmdApi->print)(cmdIoParam, " %s is directory"LINE_TERM, path);
		return;
	}

	err = lfs_file_open(&lfs, &file, path, LFS_O_WRONLY | LFS_O_CREAT);
	if (err != LFS_ERR_OK) {
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "%s() fail at %d."LINE_TERM, __FUNCTION__, __LINE__);
		return;
	}

	err = lfs_file_truncate(&lfs, &file, offset);
	if (err != LFS_ERR_OK) {
		lfs_file_close(&lfs, &file);
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "%s() fail at %d."LINE_TERM, __FUNCTION__, __LINE__);
		return;
	}

	assert (lfs_file_sync(&lfs, &file) == LFS_ERR_OK);
	assert (lfs_file_close(&lfs, &file) == LFS_ERR_OK);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "append file_name foo bar (for example) : append the string \"foo bar\" at the end of file."LINE_TERM);
	return;
}

static void smb_cmd_fsmkdir (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	char path[LFS_NAME_MAX];

	assert (IsFS_mount == true);
	if (argc != 2) goto USAGE;

	strcpy (path, argv[1]);
	assert (lfs_mkdir (&lfs, path) == LFS_ERR_OK);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "mkdir"LINE_TERM);
	return;
}

// 아래 smb_cmd_fsdir 에서만 사용하기 때문에 GET_FS_MUTEX, PUT_FS_MUTEX 를 사용하지 말 것.
static void PrintDirectory(SYS_CMD_DEVICE_NODE* pCmdIO, lfs_dir_t* dir, const char* path, int num_tabs)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	struct lfs_info info;
	int kMaxDepth = 3;

	if (num_tabs > kMaxDepth) {
		return;
	}

	while (lfs_dir_read(&lfs, dir, &info) > 0) {
		if (info.name[0] == '.') {
			continue;
		}

		for (int i = 0; i < num_tabs; ++i) {
			(*pCmdIO->pCmdApi->msg)(cmdIoParam, "\t");
		}

		(*pCmdIO->pCmdApi->print)(cmdIoParam, "%s", info.name);

		if (info.type == LFS_TYPE_DIR) {
			char subpath[LFS_NAME_MAX*2];
			(*pCmdIO->pCmdApi->msg)(cmdIoParam, "/"LINE_TERM);
			lfs_dir_t subdir;
			snprintf(subpath, LFS_NAME_MAX*2, "%s/%s", path, info.name);
			assert (lfs_dir_open(&lfs, &subdir, subpath) >= 0);
			PrintDirectory(pCmdIO, &subdir, subpath, num_tabs + 1);
			assert (lfs_dir_close(&lfs, &subdir) >= 0);
		} else {
			(*pCmdIO->pCmdApi->print)(cmdIoParam, "\t\t%ld"LINE_TERM, info.size);
		}
	}
}

static void smb_cmd_fsdir (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	lfs_dir_t root;

	assert (IsFS_mount == true);
	if (argc != 1) goto USAGE;

	assert (lfs_dir_open(&lfs, &root, "/") >= 0);
	PrintDirectory(pCmdIO, &root, "", 0);
	assert (lfs_dir_close(&lfs, &root) >= 0);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "dir"LINE_TERM);
	return;
}

static void smb_cmd_format (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 1) goto USAGE;


	assert (lfs_unmount(&lfs) == LFS_ERR_OK);
	IsFS_mount = false;
	assert (lfs_format(&lfs, &smb_lfs_config) == LFS_ERR_OK);
	assert (lfs_mount(&lfs, &smb_lfs_config) == LFS_ERR_OK);
	IsFS_mount = true;

	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "format"LINE_TERM);
	return;
}

static void config_display(SYS_CMD_DEVICE_NODE* pCmdIO, SMB_ConfigObj_t *p)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	(*pCmdIO->pCmdApi->print)(cmdIoParam, "machine_serial_no \t= %#010"PRIx32 LINE_TERM, p->machine_serial_no);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "work_mode \t\t= %s"LINE_TERM, (p->work_mode == SMB_MODE_NETWORK)?"SMB_MODE_NETWORK":"SMB_MODE_STANDALONE");
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "site address \t\t= %s"LINE_TERM, p->site_address);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "install_worker \t\t= %s"LINE_TERM, p->install_worker);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "install date \t\t= 20%02d/%d/%d"LINE_TERM, p->install_Date.Year, p->install_Date.Month, p->install_Date.Date);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "manufacture date \t= 20%02d/%d/%d"LINE_TERM, p->manufacture_Date.Year, p->manufacture_Date.Month, p->manufacture_Date.Date);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "firmware update date \t= 20%02d/%d/%d"LINE_TERM, p->fw_update_Date.Year, p->fw_update_Date.Month, p->fw_update_Date.Date);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "running firmware \t= %s"LINE_TERM, p->running_fw);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "motion_latency \t\t= %d (sec)"LINE_TERM, p->motion_latency);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "siren_on_time \t\t= %d (sec)"LINE_TERM, p->siren_on_time);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "aedt_high_watermark \t= %2d ºC"LINE_TERM, p->aedt_high_mark);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "aedt_normal_high \t= %2d ºC"LINE_TERM, p->aedt_normal_high);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "aedt_normal_low \t= %2d ºC"LINE_TERM, p->aedt_normal_low);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "aedt_low_watermark \t= %2d ºC"LINE_TERM, p->aedt_low_mark);

	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lamp_on_duty_time \t= %2d:%2d:%2d %s"LINE_TERM, \
			p->lamp_on_duty.Hours, p->lamp_on_duty.Minutes, p->lamp_on_duty.Seconds, (p->lamp_on_duty.Hours < 12)?"am":"pm");
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "lamp_off_duty_time \t= %2d:%2d:%2d %s"LINE_TERM, \
			p->lamp_off_duty.Hours, p->lamp_off_duty.Minutes, p->lamp_off_duty.Seconds, (p->lamp_off_duty.Hours < 12)?"am":"pm");

	(*pCmdIO->pCmdApi->print)(cmdIoParam, "sonic_threshold \t= 0x%04x"LINE_TERM, p->sonic_threshold);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "bright_dark_boundary \t= 0x%04x"LINE_TERM, p->bright_dark_boundary);

	return;
}

static void smb_cmd_showfsconfig (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	lfs_file_t file;
	SMB_ConfigObj_t temp_SMB_ConfigObj;
	if (argc != 1) goto USAGE;

	assert (lfs_file_open(&lfs, &file, CONFIG_FILE_NAME, LFS_O_RDWR | LFS_O_CREAT) == LFS_ERR_OK);
	assert (lfs_file_read(&lfs, &file, &temp_SMB_ConfigObj, sizeof(SMB_ConfigObj_t)) == sizeof(SMB_ConfigObj_t));
	assert (lfs_file_close(&lfs, &file) == LFS_ERR_OK);

	config_display(pCmdIO, &temp_SMB_ConfigObj);

	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "showfsconfig"LINE_TERM);
	return;
}

static void smb_cmd_showconfig (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 1) goto USAGE;

	config_display(pCmdIO, &SMB_ConfigObj);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "showconfig"LINE_TERM);
	return;
}

// Raspberry 로 보내는 메세지를 history 에 계속 넣는 것이 맞을까? 일단 그 용도에 쓰기 위해 만들어 돔..
static void smb_cmd_rbhist (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	lfs_file_t file;
	char fw_update_string[100];
	int len = 0;
	assert (IsFS_mount == true);

	if (argc != 2) goto USAGE;

	len += sprintf(&fw_update_string[0], "TEST RB message %d ", (uint16_t)strtoul(argv[1], NULL, 0));
	len += sprintf(&fw_update_string[len], "%4d/%2d/%2d %2d:%2d:%2d", \
			2000 + RTC_Bcd2ToByte(SMB_StatusObj.currentDate.Year), RTC_Bcd2ToByte(SMB_StatusObj.currentDate.Month), RTC_Bcd2ToByte(SMB_StatusObj.currentDate.Date), \
			RTC_Bcd2ToByte(SMB_StatusObj.currentTime.Hours), RTC_Bcd2ToByte(SMB_StatusObj.currentTime.Minutes), RTC_Bcd2ToByte(SMB_StatusObj.currentTime.Seconds));
	len += sprintf(&fw_update_string[len], LINE_TERM);

	assert (lfs_file_open(&lfs, &file, RB_REPORT_HISTORY_FILE, LFS_O_WRONLY | LFS_O_CREAT | LFS_O_APPEND) == LFS_ERR_OK);
	lfs_file_write(&lfs, &file, fw_update_string, len);
	assert (lfs_file_close(&lfs, &file) == LFS_ERR_OK);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "fstest 100"LINE_TERM);
	return;
}

static void smb_cmd_fstest (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	return;
}

static const SYS_CMD_DESCRIPTOR    FileSystem_CommandTbl []=
{
		{"fsshow", 			smb_cmd_fsshow, 		"\t\t- show little file system in detail"},
		{"ls", 				smb_cmd_fsls,			"\t\t\t- ls"},
		{"mkfile", 			smb_cmd_fsmkfile,		"\t\t- mkfile file_name"},
		{"del", 			smb_cmd_fsdelfile,		"\t\t- del file or directory name"},
		{"delall", 			smb_cmd_fsdelallfile,	"\t\t- delall"},
		{"cp", 				smb_cmd_fscpfile,		"\t\t\t- cp source_file_name dest_file_name"},
		{"cat", 			smb_cmd_fscatfile,		"\t\t- cat file_name"},
		{"df", 				smb_cmd_fs_df,			"\t\t\t- df (when getting free disk size)"},
		{"append", 			smb_cmd_fs_append,		"\t\t- append file_name foo bar (for example)"},
		{"trunc", 			smb_cmd_fs_trunc,		"\t\t- truncate file_name offset (for example)"},

		{"mkdir", 			smb_cmd_fsmkdir,		"\t\t- mkdir dir_name"},
		{"dir", 			smb_cmd_fsdir,			"\t\t- dir"},
		{"format", 			smb_cmd_format,			"\t\t- format"},
		{"showfsconfig", 	smb_cmd_showfsconfig,	"\t- showfsconfig"},
		{"showconfig", 		smb_cmd_showconfig,		"\t\t- showconfig"},
		{"rbhist", 			smb_cmd_rbhist,			"\t\t- rbhist 100"},
		{"fstest", 			smb_cmd_fstest,			"\t\t- fstest"},
};

bool smb_cmd_fs_add ()
{
	assert (SYS_CMD_ADDGRP(FileSystem_CommandTbl, sizeof(FileSystem_CommandTbl)/sizeof(*FileSystem_CommandTbl), "fs", ": File system command group") == true);
	return true;
}
