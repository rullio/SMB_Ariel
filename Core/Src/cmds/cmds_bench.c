/**
 ******************************************************************************
 * File Name          : cmds_bench.c
 * Description        : This file is generated by 위대한 송 인재 for Smart Bench on Feb 11, 2025
 ******************************************************************************
 *
 * COPYRIGHT(c) 2024 LMS Co. Ltd.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *   1. Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *   3. Neither the name of STMicroelectronics nor the names of its contributors
 *      may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************
 */

#include "main.h"

void smb_manipulation_begin (void);

static void smb_cmd_show_bench (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 1) {
		goto USAGE;
	}

	SMB_StatusObj.smb_data_show_flag = !SMB_StatusObj.smb_data_show_flag;

	if (SMB_StatusObj.smb_data_show_flag == true) {
		(*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, CUI_ESC_CLR);
		(*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, CUI_ESC_CUR_HOME); osDelay(1);
		(*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, CUI_ESC_CUR_HIDE); osDelay(1);
	}
	else {
		(*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, CUI_ESC_CUR_SHOW);
	}
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "showbench"LINE_TERM);
	return;
}

static void smb_cmd_set_ledbar (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	ledbarObj_t *pledbarObj;

	if (argc != 2) {
		goto USAGE;
	}

	pledbarObj = get_ledbar_handle();
	if (!strcmp (argv[1], "off")) pledbarObj->ledbar_color_set(LEDBAR_OFF);
	else if (!strcmp (argv[1], "red")) pledbarObj->ledbar_color_set(LEDBAR_RED);
	else if (!strcmp (argv[1], "yellow")) pledbarObj->ledbar_color_set(LEDBAR_YELLOW);
	else if (!strcmp (argv[1], "green")) pledbarObj->ledbar_color_set(LEDBAR_GREEN);
	else if (!strcmp (argv[1], "blue")) pledbarObj->ledbar_color_set(LEDBAR_BLUE);
	else if (!strcmp (argv[1], "white")) pledbarObj->ledbar_color_set(LEDBAR_WHITE);
	else {
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "No such color %s", argv[1]);
	}
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "ledbar off/red/green/blue/yellow/white"LINE_TERM);
	return;
}

static void smb_cmd_set_siren (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp (argv[1], "on")) SMB_ControlObj.sirenObj.siren_set(SIREN_ON);
	else if (!strcmp (argv[1], "off")) SMB_ControlObj.sirenObj.siren_set(SIREN_OFF);
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "siren on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_ltepwr (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp (argv[1], "on")) SMB_ControlObj.lteObj.lte_set(LTE_ON);
	else if (!strcmp (argv[1], "off")) SMB_ControlObj.lteObj.lte_set(LTE_OFF);
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "lte on/off"LINE_TERM);
	return;
}


// Multi meter 대면서 시험할 때 board 가 reset 되는 문제가 있음.. 차후 debug 해봐야 함..
static void smb_cmd_set_ptc (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp (argv[1], "on")) SMB_ControlObj.ptcObj.ptc_set(PTC_ON);
	else if (!strcmp (argv[1], "off")) SMB_ControlObj.ptcObj.ptc_set(PTC_OFF);
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "ptc on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_yuchar (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp (argv[1], "on")) SMB_ControlObj.yucharObj.yuchar_set(YUCHAR_ON);
	else if (!strcmp (argv[1], "off")) SMB_ControlObj.yucharObj.yuchar_set(YUCHAR_OFF);
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "yuchar on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_muchar1 (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp (argv[1], "on")) SMB_ControlObj.muchar1Obj.muchar1_set(MUCHAR1_ON);
	else if (!strcmp (argv[1], "off")) SMB_ControlObj.muchar1Obj.muchar1_set(MUCHAR1_OFF);
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "muchar1 on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_muchar2 (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp (argv[1], "on")) SMB_ControlObj.muchar2Obj.muchar2_set(MUCHAR2_ON);
	else if (!strcmp (argv[1], "off")) SMB_ControlObj.muchar2Obj.muchar2_set(MUCHAR2_OFF);
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "muchar2 on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_fan (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp (argv[1], "on")) SMB_ControlObj.fanObj.fan_set(FAN_ON);
	else if (!strcmp (argv[1], "off")) SMB_ControlObj.fanObj.fan_set(FAN_OFF);
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "fan on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_inverter (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp (argv[1], "on")) SMB_ControlObj.inverterObj.inverter_set(INVERTER_ON);
	else if (!strcmp (argv[1], "off")) SMB_ControlObj.inverterObj.inverter_set(INVERTER_OFF);
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "interver on/off"LINE_TERM);
	return;
}


static void smb_cmd_set_speaker (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp (argv[1], "on")) SMB_ControlObj.speakerObj.speaker_set(SPEAKER_ON);
	else if (!strcmp (argv[1], "off")) SMB_ControlObj.speakerObj.speaker_set(SPEAKER_OFF);
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "speaker on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_lcd (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp (argv[1], "on")) SMB_ControlObj.lcdObj.lcd_set(LCD_ON);
	else if (!strcmp (argv[1], "off")) SMB_ControlObj.lcdObj.lcd_set(LCD_OFF);
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "lcd on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_lamp (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	uint32_t lamp_level;

	if (argc != 2) {
		goto USAGE;
	}

	lamp_level = (uint32_t)strtoul(argv[1], NULL, 0);

	if (lamp_level > 9) goto USAGE;
	if (lamp_level < 0) goto USAGE;

	SMB_ControlObj.lampObj.lamp_set((lamp_level_t)lamp_level);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "lamp 0~9 (illuminace)"LINE_TERM);
	return;
}

static void smb_cmd_set_ledact (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp(argv[1], "on")) led_act_on;
	else if (!strcmp(argv[1], "off")) led_act_off;
	else if (!strcmp(argv[1], "toggle")) led_act_toggle;
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "ledact on/off/toggle"LINE_TERM);
	return;
}

static void smb_cmd_set_ledcom (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp(argv[1], "on")) led_com_on;
	else if (!strcmp(argv[1], "off")) led_com_off;
	else if (!strcmp(argv[1], "toggle")) led_com_toggle;
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "ledact on/off/toggle"LINE_TERM);
	return;
}

static void smb_cmd_set_ledlia0 (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp(argv[1], "on")) led_lia0_on;
	else if (!strcmp(argv[1], "off")) led_lia0_off;
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "ledlia0 on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_ledlia1 (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp(argv[1], "on")) led_lia1_on;
	else if (!strcmp(argv[1], "off")) led_lia1_off;
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "ledlia1 on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_ledlia2 (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp(argv[1], "on")) led_lia2_on;
	else if (!strcmp(argv[1], "off")) led_lia2_off;
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "ledlia2 on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_launchdate (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	uint8_t Year, Month, Date, WeekDay;

	if (argc != 5) {
		goto USAGE;
	}

	Year = (uint8_t)strtoul(argv[1], NULL, 0);
	Month = (uint8_t)strtoul(argv[2], NULL, 0);
	Date = (uint8_t)strtoul(argv[3], NULL, 0);
	WeekDay = (uint8_t)strtoul(argv[4], NULL, 0);

	if (Year > 99) goto USAGE;
	if (Month > 12) goto USAGE;
	if (Date > 31) goto USAGE;
	if (WeekDay > 7) goto USAGE;

	SMB_StatusObj.launchDate.Year = RTC_ByteToBcd2(Year);
	SMB_StatusObj.launchDate.Month = RTC_ByteToBcd2(Month);
	SMB_StatusObj.launchDate.Date = RTC_ByteToBcd2(Date);
	SMB_StatusObj.launchDate.WeekDay = RTC_ByteToBcd2(WeekDay);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "setlaunchdate 25 9 11 1 (Monday for example)"LINE_TERM);
	return;
}

static void smb_cmd_set_launchtime (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	uint8_t Hours, Minutes, Seconds;

	if (argc != 4) {
		goto USAGE;
	}

	Hours = (uint8_t)strtoul (argv[1], NULL, 0);
	Minutes = (uint8_t)strtoul (argv[2], NULL, 0);
	Seconds = (uint8_t)strtoul (argv[3], NULL, 0);

	if (Hours > 23) goto USAGE;
	if (Minutes > 59) goto USAGE;
	if (Seconds > 59) goto USAGE;

	SMB_StatusObj.launchTime.Hours = RTC_ByteToBcd2(Hours);
	SMB_StatusObj.launchTime.Minutes = RTC_ByteToBcd2(Minutes);
	SMB_StatusObj.launchTime.Seconds = RTC_ByteToBcd2(Seconds);
	SMB_StatusObj.launchTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
	SMB_StatusObj.launchTime.StoreOperation = RTC_STOREOPERATION_RESET;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "setlaunchtime 13 39 11"LINE_TERM);
	return;
}

static void smb_cmd_show_adc (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 1) {
		goto USAGE;
	}

	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "converted data"LINE_TERM);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "YUI = %#06"PRIx16 LINE_TERM, SMB_adc_value.YUI);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "MUI1 = %#06"PRIx16 LINE_TERM, SMB_adc_value.MUI1);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "MUI2 = %#06"PRIx16 LINE_TERM, SMB_adc_value.MUI2);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "AEDT = %#06"PRIx16 LINE_TERM, SMB_adc_value.AEDT);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "CDS = %#06"PRIx16 LINE_TERM, SMB_adc_value.CDS);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "TEMP = %2d"LINE_TERM, SMB_adc_value.TEMP);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "VBAT = %#06"PRIx16 LINE_TERM, SMB_adc_value.VBAT);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "VREF = %4d(mV)"LINE_TERM, SMB_adc_value.VREF);

	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "raw data"LINE_TERM);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "yui = %#06"PRIx16 LINE_TERM, SMB_adc_value.yui_raw_data);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "mui1 = %#06"PRIx16 LINE_TERM, SMB_adc_value.mui1_raw_data);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "mui2 = %#06"PRIx16 LINE_TERM, SMB_adc_value.mui2_raw_data);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "aedt = %#06"PRIx16 LINE_TERM, SMB_adc_value.aedt_raw_data);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "cds = %#06"PRIx16 LINE_TERM, SMB_adc_value.cds_raw_data);

	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "showadc"LINE_TERM);
	return;
}

static void smb_cmd_benchtest (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 1) {
		goto USAGE;
	}

	smb_manipulation_begin();
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "benchtest"LINE_TERM);
	return;
}

static void smb_cmd_dwttest (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	uint32_t delay_us_before, delay_us_after;

	if (argc != 1) {
		goto USAGE;
	}

	delay_us_before = DWT_GetTickUS();
	osDelay(1);
	delay_us_after = DWT_GetTickUS();
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "delay_us_before = %ld, delay_us_after = %ld"LINE_TERM, delay_us_before, delay_us_after);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "osDelay(1) = %ld"LINE_TERM, delay_us_after - delay_us_before);

	delay_us_before = DWT_GetTickUS();
	HAL_Delay(1);
	delay_us_after = DWT_GetTickUS();
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "delay_us_before = %ld, delay_us_after = %ld"LINE_TERM, delay_us_before, delay_us_after);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "HAL_Delay(1) = %ld"LINE_TERM, delay_us_after - delay_us_before);

	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "dwttest"LINE_TERM);
	return;
}

static void smb_cmd_mani (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 1) {
		goto USAGE;
	}
	SMB_StatusObj.console_mani_flag = !SMB_StatusObj.console_mani_flag;

	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "mani"LINE_TERM);
	return;
}

#if 0

static void smb_cmd_set_offduty (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	uint8_t Hours, Minutes;

	if (argc != 3) {
		goto USAGE;
	}

	Hours = (uint8_t)strtoul(argv[1], NULL, 10);
	Minutes = (uint8_t)strtoul(argv[2], NULL, 10);

	SBConfigObj.lamp_off_duty.Hours = Hours;
	SBConfigObj.lamp_off_duty.Minutes = Minutes;
	assert (duty_minutes_set(&SBStatusObj) == true);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "setoffduty 6 10 (for example 6:10 am)"LINE_TERM);
	return;
}

static void smb_cmd_set_onduty (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	uint8_t Hours, Minutes;

	if (argc != 3) {
		goto USAGE;
	}

	Hours = (uint8_t)strtoul(argv[1], NULL, 10);
	Minutes = (uint8_t)strtoul(argv[2], NULL, 10);

	SBConfigObj.lamp_on_duty.Hours = Hours;
	SBConfigObj.lamp_on_duty.Minutes = Minutes;
	assert (duty_minutes_set(&SBStatusObj) == true);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "setoffduty 6 10 (for example 6:10 am)"LINE_TERM);
	return;
}
#endif

static const SYS_CMD_DESCRIPTOR    bench_CommandTbl []=
{
		{"showbench",		smb_cmd_show_bench,		"\t\t- showbench"},
		{"smb",				smb_cmd_show_bench,		"\t\t- smb"},
		{"ledbar",			smb_cmd_set_ledbar,		"\t\t- ledbar off/red/green/blue/yellow/white"},
		{"siren",			smb_cmd_set_siren,		"\t\t- siren on/off"},
		{"lte",				smb_cmd_set_ltepwr,		"\t\t- lte on/off"},
		{"ptc",				smb_cmd_set_ptc,		"\t\t- ptc on/off"},
		{"yuchar",			smb_cmd_set_yuchar,		"\t\t- yuchar on/off"},
		{"muchar1",			smb_cmd_set_muchar1,	"\t\t- muchar1 on/off"},
		{"muchar2",			smb_cmd_set_muchar2,	"\t\t- muchar2 on/off"},
		{"fan",				smb_cmd_set_fan,		"\t\t- fan on/off"},
		{"inverter",		smb_cmd_set_inverter,	"\t\t- inverter on/off"},
		{"speaker",			smb_cmd_set_speaker,	"\t\t- speaker on/off"},
		{"lcd",				smb_cmd_set_lcd,		"\t\t- lcd on/off"},
		{"lamp",			smb_cmd_set_lamp,		"\t\t- lamp 0~9"},
		{"ledact",			smb_cmd_set_ledact,		"\t\t- ledact on/off/toggle"},
		{"ledcom",			smb_cmd_set_ledcom,		"\t\t- ledcom on/off/toggle"},
		{"ledlia0",			smb_cmd_set_ledlia0,	"\t\t- ledlia0 on/off"},
		{"ledlia1",			smb_cmd_set_ledlia1,	"\t\t- ledlia1 on/off"},
		{"ledlia2",			smb_cmd_set_ledlia2,	"\t\t- ledlia2 on/off"},
		{"setlaunchdate",	smb_cmd_set_launchdate,	"\t- setlaunchdate 25 9 11 1 (Monday for example)"},
		{"setlaunchtime",	smb_cmd_set_launchtime,	"\t- setlaunchtime 13 39 11"},
		{"showadc",			smb_cmd_show_adc,		"\t\t- showadc"},
		{"benchtest",		smb_cmd_benchtest,		"\t\t- benchtest"},
		{"dwttest",			smb_cmd_dwttest,		"\t\t- dwttest"},
		{"mani",			smb_cmd_mani,		"\t\t- mani"},
#if 0
		{"setoffduty",		smb_cmd_set_offduty,	"\t\t- setoffduty 6 10 (for example 6:10 am)"},
		{"setonduty",		smb_cmd_set_onduty,		"\t\t- setonduty 18 15 (for example 18:15 pm)"},
#endif

};

bool smb_cmd_bench_add ()
{
	assert (SYS_CMD_ADDGRP(bench_CommandTbl, sizeof(bench_CommandTbl)/sizeof(*bench_CommandTbl), "bench", ": bench command group") == true);
	return true;
}

