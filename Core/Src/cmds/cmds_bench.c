/**
 ******************************************************************************
 * File Name          : cmds_bench.c
 * Description        : This file is generated by 위대한 송 인재 for Smart Bench on Feb 11, 2025
 ******************************************************************************
 *
 * COPYRIGHT(c) 2024 LMS Co. Ltd.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *   1. Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *   3. Neither the name of STMicroelectronics nor the names of its contributors
 *      may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************
 */

#include "main.h"

static void smb_cmd_show_bench (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 1) goto USAGE;

	SMB_StatusObj.smb_data_show_flag = !SMB_StatusObj.smb_data_show_flag;

	if (SMB_StatusObj.smb_data_show_flag == true) {
		(*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, CUI_ESC_CLR);
		(*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, CUI_ESC_CUR_HOME); osDelay(1);
		(*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, CUI_ESC_CUR_HIDE); osDelay(1);
	}
	else {
		(*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, CUI_ESC_CUR_SHOW);
	}
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "showbench"LINE_TERM);
	return;
}

static void smb_cmd_set_ledbar (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	ledbarObj_t *pledbarObj;

	if (argc != 2) goto USAGE;

	pledbarObj = get_ledbar_handle();
	if (!strcmp (argv[1], "off")) pledbarObj->ledbar_color = LEDBAR_OFF;
	else if (!strcmp (argv[1], "red")) pledbarObj->ledbar_color = LEDBAR_RED;
	else if (!strcmp (argv[1], "yellow")) pledbarObj->ledbar_color = LEDBAR_YELLOW;
	else if (!strcmp (argv[1], "green")) pledbarObj->ledbar_color = LEDBAR_GREEN;
	else if (!strcmp (argv[1], "blue")) pledbarObj->ledbar_color = LEDBAR_BLUE;
	else if (!strcmp (argv[1], "white")) pledbarObj->ledbar_color = LEDBAR_WHITE;
	else goto USAGE;

	pledbarObj->ledbar_color_set(pledbarObj->ledbar_color);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "ledbar off/red/green/blue/yellow/white"LINE_TERM);
	return;
}

static void smb_cmd_set_siren (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	sirenObj_t *psirenObj;

	if (argc != 2) goto USAGE;

	psirenObj = get_siren_handle();
	if (!strcmp (argv[1], "on")) psirenObj->siren_flag = SIREN_ON;
	else if (!strcmp (argv[1], "off")) psirenObj->siren_flag = SIREN_OFF;
	else goto USAGE;

	psirenObj->siren_set(psirenObj->siren_flag);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "siren on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_sirenset (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) goto USAGE;

	SMB_ConfigObj.siren_on_time = strtoul(argv[1], NULL, 10);
	save_smb_configObj_onto_fs(&SMB_ConfigObj);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "siren_on_time = %d"LINE_TERM, SMB_ConfigObj.siren_on_time);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "siren 10 (for example 10 sec)"LINE_TERM);
	return;
}

static void smb_cmd_set_motionlatency (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) goto USAGE;

	SMB_ConfigObj.motion_latency = strtoul(argv[1], NULL, 10);
	save_smb_configObj_onto_fs(&SMB_ConfigObj);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "motion_latency = %d"LINE_TERM, SMB_ConfigObj.motion_latency);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "latency 10 (for example 10 sec)"LINE_TERM);
	return;
}

static void smb_cmd_set_ltepwr (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	lteObj_t *plteObj;

	if (argc != 2) goto USAGE;

	plteObj = get_lte_handle();

	if (!strcmp (argv[1], "on")) plteObj->lte_flag = LTE_ON;
	else if (!strcmp (argv[1], "off")) plteObj->lte_flag = LTE_OFF;
	else goto USAGE;

	plteObj->lte_set(plteObj->lte_flag);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "lte on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_ptc (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	ptcObj_t *pptcObj;

	if (argc != 2) goto USAGE;

	pptcObj = get_ptc_handle();

	if (!strcmp (argv[1], "on")) pptcObj->ptc_flag = PTC_ON;
	else if (!strcmp (argv[1], "off")) pptcObj->ptc_flag = PTC_OFF;
	else goto USAGE;

	pptcObj->ptc_set(pptcObj->ptc_flag);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "ptc on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_yuchar (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	yucharObj_t *pyucharObj;

	if (argc != 2) goto USAGE;

	pyucharObj = get_yuchar_handle();

	if (!strcmp (argv[1], "on")) pyucharObj->yuchar_flag = YUCHAR_ON;
	else if (!strcmp (argv[1], "off")) pyucharObj->yuchar_flag = YUCHAR_OFF;
	else goto USAGE;

	pyucharObj->yuchar_set(pyucharObj->yuchar_flag);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "yuchar on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_muchar1 (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	muchar1Obj_t *pmuchar1Obj;

	if (argc != 2) goto USAGE;

	pmuchar1Obj = get_muchar1_handle();

	if (!strcmp (argv[1], "on")) pmuchar1Obj->muchar1_flag = MUCHAR1_ON;
	else if (!strcmp (argv[1], "off")) pmuchar1Obj->muchar1_flag = MUCHAR1_OFF;
	else goto USAGE;

	pmuchar1Obj->muchar1_set(pmuchar1Obj->muchar1_flag);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "muchar1 on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_muchar2 (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	muchar2Obj_t *pmuchar2Obj;

	if (argc != 2) goto USAGE;

	pmuchar2Obj = get_muchar2_handle();

	if (!strcmp (argv[1], "on")) pmuchar2Obj->muchar2_flag = MUCHAR2_ON;
	else if (!strcmp (argv[1], "off")) pmuchar2Obj->muchar2_flag = MUCHAR2_OFF;
	else goto USAGE;

	pmuchar2Obj->muchar2_set(pmuchar2Obj->muchar2_flag);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "muchar2 on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_fan (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	fanObj_t *pfanObj;

	if (argc != 2) goto USAGE;

	pfanObj = get_fan_handle();

	if (!strcmp (argv[1], "on")) pfanObj->fan_flag = FAN_ON;
	else if (!strcmp (argv[1], "off")) pfanObj->fan_flag = FAN_OFF;
	else goto USAGE;

	pfanObj->fan_set(pfanObj->fan_flag);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "fan on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_inverter (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	inverterObj_t *pinverterObj;

	if (argc != 2) goto USAGE;

	pinverterObj = get_inverter_handle();

	if (!strcmp (argv[1], "on")) pinverterObj->inverter_flag = INVERTER_ON;
	else if (!strcmp (argv[1], "off")) pinverterObj->inverter_flag = INVERTER_ON;
	else goto USAGE;

	pinverterObj->inverter_set(pinverterObj->inverter_flag);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "interver on/off"LINE_TERM);
	return;
}


static void smb_cmd_set_speaker (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	speakerObj_t *pspeakerObj;

	if (argc != 2) goto USAGE;

	pspeakerObj = get_speaker_handle();

	if (!strcmp (argv[1], "on")) pspeakerObj->speaker_flag = SPEAKER_ON;
	else if (!strcmp (argv[1], "off")) pspeakerObj->speaker_flag = SPEAKER_OFF;
	else goto USAGE;

	pspeakerObj->speaker_set(pspeakerObj->speaker_flag);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "speaker on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_lcd (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	lcdObj_t *plcdObj;

	if (argc != 2) goto USAGE;

	plcdObj = get_lcd_handle();

	if (!strcmp (argv[1], "on")) plcdObj->lcd_flag = LCD_ON;
	else if (!strcmp (argv[1], "off")) plcdObj->lcd_flag = LCD_OFF;
	else goto USAGE;

	plcdObj->lcd_set(plcdObj->lcd_flag);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "lcd on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_lamp (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	uint32_t lamp_level;
	lampObj_t *plampObj;

	if (argc != 2) goto USAGE;

	plampObj = get_lamp_handle();
	lamp_level = (uint32_t)strtoul(argv[1], NULL, 0);

	if (lamp_level > 9) goto USAGE;

	plampObj->lamp_set(lamp_level);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "lamp 0~9 (illuminace)"LINE_TERM);
	return;
}

static void smb_cmd_set_ledact (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) goto USAGE;

	if (!strcmp(argv[1], "on")) led_act_on;
	else if (!strcmp(argv[1], "off")) led_act_off;
	else if (!strcmp(argv[1], "toggle")) led_act_toggle;
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "ledact on/off/toggle"LINE_TERM);
	return;
}

static void smb_cmd_set_ledcom (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) goto USAGE;

	if (!strcmp(argv[1], "on")) led_com_on;
	else if (!strcmp(argv[1], "off")) led_com_off;
	else if (!strcmp(argv[1], "toggle")) led_com_toggle;
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "ledact on/off/toggle"LINE_TERM);
	return;
}

static void smb_cmd_set_aclamp0 (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) goto USAGE;

	if (!strcmp(argv[1], "on")) led_lia0_on;
	else if (!strcmp(argv[1], "off")) led_lia0_off;
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "ledlia0 on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_aclamp1 (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) goto USAGE;

	if (!strcmp(argv[1], "on")) led_lia1_on;
	else if (!strcmp(argv[1], "off")) led_lia1_off;
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "ledlia1 on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_aclamp2 (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) goto USAGE;

	if (!strcmp(argv[1], "on")) led_lia2_on;
	else if (!strcmp(argv[1], "off")) led_lia2_off;
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "aclamp2 on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_launchdate (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	uint8_t Year, Month, Date, WeekDay;

	if (argc != 5) goto USAGE;

	Year = (uint8_t)strtoul(argv[1], NULL, 0);
	Month = (uint8_t)strtoul(argv[2], NULL, 0);
	Date = (uint8_t)strtoul(argv[3], NULL, 0);
	WeekDay = (uint8_t)strtoul(argv[4], NULL, 0);

	if (Year > 99) goto USAGE;
	if (Month > 12) goto USAGE;
	if (Date > 31) goto USAGE;
	if (WeekDay > 7) goto USAGE;

	SMB_StatusObj.launchDate.Year = RTC_ByteToBcd2(Year);
	SMB_StatusObj.launchDate.Month = RTC_ByteToBcd2(Month);
	SMB_StatusObj.launchDate.Date = RTC_ByteToBcd2(Date);
	SMB_StatusObj.launchDate.WeekDay = RTC_ByteToBcd2(WeekDay);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "setlaunchdate 25 9 11 1 (Monday for example)"LINE_TERM);
	return;
}

static void smb_cmd_set_launchtime (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	uint8_t Hours, Minutes, Seconds;

	if (argc != 4) goto USAGE;

	Hours = (uint8_t)strtoul (argv[1], NULL, 0);
	Minutes = (uint8_t)strtoul (argv[2], NULL, 0);
	Seconds = (uint8_t)strtoul (argv[3], NULL, 0);

	if (Hours > 23) goto USAGE;
	if (Minutes > 59) goto USAGE;
	if (Seconds > 59) goto USAGE;

	SMB_StatusObj.launchTime.Hours = RTC_ByteToBcd2(Hours);
	SMB_StatusObj.launchTime.Minutes = RTC_ByteToBcd2(Minutes);
	SMB_StatusObj.launchTime.Seconds = RTC_ByteToBcd2(Seconds);
	SMB_StatusObj.launchTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
	SMB_StatusObj.launchTime.StoreOperation = RTC_STOREOPERATION_RESET;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "setlaunchtime 13 39 11"LINE_TERM);
	return;
}

static void smb_cmd_show_adc (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 1) goto USAGE;

	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "converted data"LINE_TERM);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "YUI = %#06"PRIx16 LINE_TERM, SMB_adc_value.YUI);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "MUI1 = %#06"PRIx16 LINE_TERM, SMB_adc_value.MUI1);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "MUI2 = %#06"PRIx16 LINE_TERM, SMB_adc_value.MUI2);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "AEDT = %#06"PRIx16 LINE_TERM, SMB_adc_value.AEDT);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "CDS = %#06"PRIx16 LINE_TERM, SMB_adc_value.CDS);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "TEMP = %2d"LINE_TERM, SMB_adc_value.TEMP);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "VBAT = %#06"PRIx16 LINE_TERM, SMB_adc_value.VBAT);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "VREF = %4d(mV)"LINE_TERM, SMB_adc_value.VREF);

	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "raw data"LINE_TERM);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "yui = %#06"PRIx16 LINE_TERM, SMB_adc_value.yui_raw_data);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "mui1 = %#06"PRIx16 LINE_TERM, SMB_adc_value.mui1_raw_data);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "mui2 = %#06"PRIx16 LINE_TERM, SMB_adc_value.mui2_raw_data);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "aedt = %#06"PRIx16 LINE_TERM, SMB_adc_value.aedt_raw_data);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "cds = %#06"PRIx16 LINE_TERM, SMB_adc_value.cds_raw_data);

	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "showadc"LINE_TERM);
	return;
}

static void smb_cmd_dwttest (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	uint32_t delay_us_before, delay_us_after;

	if (argc != 1) goto USAGE;

	delay_us_before = DWT_GetTickUS();
	osDelay(1);
	delay_us_after = DWT_GetTickUS();
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "delay_us_before = %ld, delay_us_after = %ld"LINE_TERM, delay_us_before, delay_us_after);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "osDelay(1) = %ld"LINE_TERM, delay_us_after - delay_us_before);

	delay_us_before = DWT_GetTickUS();
	HAL_Delay(1);
	delay_us_after = DWT_GetTickUS();
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "delay_us_before = %ld, delay_us_after = %ld"LINE_TERM, delay_us_before, delay_us_after);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "HAL_Delay(1) = %ld"LINE_TERM, delay_us_after - delay_us_before);

	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "dwttest"LINE_TERM);
	return;
}

static void smb_cmd_manual (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) goto USAGE;

	if (!strcmp(argv[1], "on")) SMB_StatusObj.manual_mode = true;
	else if (!strcmp(argv[1], "off")) SMB_StatusObj.manual_mode = false;
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "manual on/off"LINE_TERM);
	return;
}

static void smb_cmd_fake_aedt (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	int16_t fake_temp;

	if (argc == 1) {
		SMB_StatusObj.fake_AEDT.IsFaking = !SMB_StatusObj.fake_AEDT.IsFaking;
		return;
	}
	else if (argc == 2) {
		SMB_StatusObj.fake_AEDT.IsFaking = FAKE_AEDT_YES;
		fake_temp = (uint16_t)strtoul(argv[1], NULL, 10);
		if (fake_temp > 50 || fake_temp < -30) goto USAGE;
		else SMB_StatusObj.fake_AEDT.fake_temp = fake_temp;
		return;
	}
	else {
		goto USAGE;
	}

	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "fakeaedt"LINE_TERM);
	return;
}

#if 0

static void smb_cmd_set_offduty (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	uint8_t Hours, Minutes;

	if (argc != 3) {
		goto USAGE;
	}

	Hours = (uint8_t)strtoul(argv[1], NULL, 10);
	Minutes = (uint8_t)strtoul(argv[2], NULL, 10);

	SBConfigObj.lamp_off_duty.Hours = Hours;
	SBConfigObj.lamp_off_duty.Minutes = Minutes;
	assert (duty_minutes_set(&SBStatusObj) == true);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "setoffduty 6 10 (for example 6:10 am)"LINE_TERM);
	return;
}

static void smb_cmd_set_onduty (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	uint8_t Hours, Minutes;

	if (argc != 3) {
		goto USAGE;
	}

	Hours = (uint8_t)strtoul(argv[1], NULL, 10);
	Minutes = (uint8_t)strtoul(argv[2], NULL, 10);

	SBConfigObj.lamp_on_duty.Hours = Hours;
	SBConfigObj.lamp_on_duty.Minutes = Minutes;
	assert (duty_minutes_set(&SBStatusObj) == true);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "setoffduty 6 10 (for example 6:10 am)"LINE_TERM);
	return;
}
#endif

static const SYS_CMD_DESCRIPTOR    bench_CommandTbl []=
{
		{"showbench",		smb_cmd_show_bench,		"\t\t- showbench"},
		{"smb",				smb_cmd_show_bench,		"\t\t- smb"},
		{"ledbar",			smb_cmd_set_ledbar,		"\t\t- ledbar off/red/green/blue/yellow/white"},
		{"siren",			smb_cmd_set_siren,		"\t\t- siren on/off"},
		{"sirenset",		smb_cmd_set_sirenset,	"\t\t- sirenset 30 (siren wailing time for 30 seconds)"},
		{"latency",			smb_cmd_set_motionlatency,	"\t\t- latency 30 (motion latency for 30 seconds)"},
		{"lte",				smb_cmd_set_ltepwr,		"\t\t- lte on/off"},
		{"ptc",				smb_cmd_set_ptc,		"\t\t- ptc on/off"},
		{"yuchar",			smb_cmd_set_yuchar,		"\t\t- yuchar on/off"},
		{"muchar1",			smb_cmd_set_muchar1,	"\t\t- muchar1 on/off"},
		{"muchar2",			smb_cmd_set_muchar2,	"\t\t- muchar2 on/off"},
		{"fan",				smb_cmd_set_fan,		"\t\t- fan on/off"},
		{"inverter",		smb_cmd_set_inverter,	"\t\t- inverter on/off"},
		{"speaker",			smb_cmd_set_speaker,	"\t\t- speaker on/off"},
		{"lcd",				smb_cmd_set_lcd,		"\t\t- lcd on/off"},
		{"lamp",			smb_cmd_set_lamp,		"\t\t- lamp 0~9"},
		{"ledact",			smb_cmd_set_ledact,		"\t\t- ledact on/off/toggle"},
		{"ledcom",			smb_cmd_set_ledcom,		"\t\t- ledcom on/off/toggle"},
		{"aclamp0",			smb_cmd_set_aclamp0,	"\t\t- aclamp0 on/off"},
		{"aclamp1",			smb_cmd_set_aclamp1,	"\t\t- aclamp1 on/off"},
		{"aclamp2",			smb_cmd_set_aclamp2,	"\t\t- aclamp2 on/off"},
		{"setlaunchdate",	smb_cmd_set_launchdate,	"\t- setlaunchdate 25 9 11 1 (Monday for example)"},
		{"setlaunchtime",	smb_cmd_set_launchtime,	"\t- setlaunchtime 13 39 11"},
		{"showadc",			smb_cmd_show_adc,		"\t\t- showadc"},
		{"dwttest",			smb_cmd_dwttest,		"\t\t- dwttest"},
		{"manual",			smb_cmd_manual,			"\t\t- manual on/off"},
		{"fakeaedt",		smb_cmd_fake_aedt,		"\t\t- fakeaedt (-30 ~ 50)"},
#if 0
		{"setoffduty",		smb_cmd_set_offduty,	"\t\t- setoffduty 6 10 (for example 6:10 am)"},
		{"setonduty",		smb_cmd_set_onduty,		"\t\t- setonduty 18 15 (for example 18:15 pm)"},
#endif

};

bool smb_cmd_bench_add ()
{
	assert (SYS_CMD_ADDGRP(bench_CommandTbl, sizeof(bench_CommandTbl)/sizeof(*bench_CommandTbl), "bench", ": bench command group") == true);
	return true;
}

