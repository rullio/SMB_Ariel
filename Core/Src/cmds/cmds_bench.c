/**
 ******************************************************************************
 * File Name          : cmds_bench.c
 * Description        : This file is generated by 위대한 송 인재 for Smart Bench on Feb 11, 2025
 ******************************************************************************
 *
 * COPYRIGHT(c) 2024 LMS Co. Ltd.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *   1. Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *   3. Neither the name of STMicroelectronics nor the names of its contributors
 *      may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************
 */

#include "main.h"

static void smb_cmd_show_bench (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 1) {
		goto USAGE;
	}

	SMB_StatusObj.bench_data_show_flag = !SMB_StatusObj.bench_data_show_flag;

	if (SMB_StatusObj.bench_data_show_flag == true) {
		(*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, CUI_ESC_CLR);
		(*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, CUI_ESC_CUR_HOME); osDelay(1);
		(*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, CUI_ESC_CUR_HIDE); osDelay(1);
	}
	else {
		(*pCmdIO->pCmdApi->msg)(pCmdIO->cmdIoParam, CUI_ESC_CUR_SHOW);
	}
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "showbench"LINE_TERM);
	return;
}

static void smb_cmd_set_ledbar (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	ledbarObj_t *pledbarObj;

	if (argc != 2) {
		goto USAGE;
	}

	pledbarObj = get_ledbar_handle();
	if (!strcmp (argv[1], "off")) pledbarObj->ledbar_color_set(LEDBAR_OFF);
	else if (!strcmp (argv[1], "red")) pledbarObj->ledbar_color_set(LEDBAR_RED);
	else if (!strcmp (argv[1], "yellow")) pledbarObj->ledbar_color_set(LEDBAR_YELLOW);
	else if (!strcmp (argv[1], "green")) pledbarObj->ledbar_color_set(LEDBAR_GREEN);
	else if (!strcmp (argv[1], "blue")) pledbarObj->ledbar_color_set(LEDBAR_BLUE);
	else if (!strcmp (argv[1], "white")) pledbarObj->ledbar_color_set(LEDBAR_WHITE);
	else {
		(*pCmdIO->pCmdApi->print)(cmdIoParam, "No such color %s", argv[1]);
	}
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "ledbar off/red/green/blue/yellow/white"LINE_TERM);
	return;
}

static void smb_cmd_set_siren (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp (argv[1], "on")) SMB_ControlObj.sirenObj.siren_set(SIREN_ON);
	else if (!strcmp (argv[1], "off")) SMB_ControlObj.sirenObj.siren_set(SIREN_OFF);
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "siren on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_ltepwr (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp (argv[1], "on")) SMB_ControlObj.lteObj.lte_set(LTE_ON);
	else if (!strcmp (argv[1], "off")) SMB_ControlObj.lteObj.lte_set(LTE_OFF);
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "lte on/off"LINE_TERM);
	return;
}


// Multi meter 대면서 시험할 때 board 가 reset 되는 문제가 있음.. 차후 debug 해봐야 함..
static void smb_cmd_set_ptc (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp (argv[1], "on")) SMB_ControlObj.ptcObj.ptc_set(PTC_ON);
	else if (!strcmp (argv[1], "off")) SMB_ControlObj.ptcObj.ptc_set(PTC_OFF);
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "ptc on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_yuchar (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp (argv[1], "on")) SMB_ControlObj.yucharObj.yuchar_set(YUCHAR_ON);
	else if (!strcmp (argv[1], "off")) SMB_ControlObj.yucharObj.yuchar_set(YUCHAR_OFF);
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "yuchar on/off"LINE_TERM);
	return;
}


#if 0
static void smb_cmd_show_adc (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 1) {
		goto USAGE;
	}

	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "converted data"LINE_TERM);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "YUI = %#06"PRIx16 LINE_TERM, SB_adc_value.YUI);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "MUI1 = %#06"PRIx16 LINE_TERM, SB_adc_value.MUI1);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "MUI2 = %#06"PRIx16 LINE_TERM, SB_adc_value.MUI2);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "AEDT = %#06"PRIx16 LINE_TERM, SB_adc_value.AEDT);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "CDS = %#06"PRIx16 LINE_TERM, SB_adc_value.CDS);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "TEMP = %2d"LINE_TERM, SB_adc_value.TEMP);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "VBAT = %#06"PRIx16 LINE_TERM, SB_adc_value.VBAT);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "VREF = %4d(mV)"LINE_TERM, SB_adc_value.VREF);

	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "raw data"LINE_TERM);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "yui = %#06"PRIx16 LINE_TERM, SB_adc_value.yui_raw_data);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "mui1 = %#06"PRIx16 LINE_TERM, SB_adc_value.mui1_raw_data);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "mui2 = %#06"PRIx16 LINE_TERM, SB_adc_value.mui2_raw_data);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "aedt = %#06"PRIx16 LINE_TERM, SB_adc_value.aedt_raw_data);
	(*pCmdIO->pCmdApi->print)(cmdIoParam, "cds = %#06"PRIx16 LINE_TERM, SB_adc_value.cds_raw_data);

	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "showadc"LINE_TERM);
	return;
}


static void smb_cmd_set_charger (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp (argv[1], "on")) chargerObj.charger_set(CHARGER_ON);
	else if (!strcmp (argv[1], "off")) chargerObj.charger_set(CHARGER_OFF);
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "charger on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_inverter (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp (argv[1], "on")) inverterObj.inverter_set(INVERTER_ON);
	else if (!strcmp (argv[1], "off")) inverterObj.inverter_set(INVERTER_OFF);
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "interver on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_lcdpwr (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp (argv[1], "on")) lcdObj.lcdpwr_set(LCD_PWR_ON);
	else if (!strcmp (argv[1], "off")) lcdObj.lcdpwr_set(LCD_PWR_OFF);
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "lcdpwr on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_lamp (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp (argv[1], "on")) lamp_on;
	else if (!strcmp (argv[1], "off")) lamp_off;
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "lamp 0~9 (illuminace)"LINE_TERM);
	return;
}

static void smb_cmd_set_fan (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp (argv[1], "on")) fanObj.fan_pwr_set(FAN_PWR_ON);
	else if (!strcmp (argv[1], "off")) fanObj.fan_pwr_set(FAN_PWR_OFF);
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "fan on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_muchar1 (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp (argv[1], "on")) muchar1Obj.muchar1_pwr_set(MUCHAR1_PWR_ON);
	else if (!strcmp (argv[1], "off")) muchar1Obj.muchar1_pwr_set(MUCHAR1_PWR_OFF);
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "muchar1 on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_muchar2 (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp (argv[1], "on")) muchar2Obj.muchar2_pwr_set(MUCHAR2_PWR_ON);
	else if (!strcmp (argv[1], "off")) muchar2Obj.muchar2_pwr_set(MUCHAR2_PWR_OFF);
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "muchar2 on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_spare (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	uint32_t spare_no;

	if (argc != 3) {
		goto USAGE;
	}

	spare_no = strtoul(argv[1], NULL, 0);
	if (spare_no > 5) goto USAGE;
	if (spare_no < 1) goto USAGE;

	if (!strcmp (argv[2], "on")) {
		switch (spare_no) {
		case 1 : spare1_on; break;
		case 2 : spare2_on; break;
//		case 3 : spare3_on; break;
		case 4 : spare4_on; break;
		case 5 : spare5_on; break;
		default : assert (0 == 1); break;
		}
	}
	else if (!strcmp (argv[2], "off")) {
		switch (spare_no) {
		case 1 : spare1_off; break;
		case 2 : spare2_off; break;
//		case 3 : spare3_off; break;
		case 4 : spare4_off; break;
		case 5 : spare5_off; break;
		default : assert (0 == 1); break;
		}
	}
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "spare 1/2/3/4/5 on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_ledact (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp(argv[1], "on")) led_act_on;
	else if (!strcmp(argv[1], "off")) led_act_off;
	else if (!strcmp(argv[1], "toggle")) led_act_toggle;
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "ledact on/off/toggle"LINE_TERM);
	return;
}

static void smb_cmd_set_ledcom (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp(argv[1], "on")) led_com_on;
	else if (!strcmp(argv[1], "off")) led_com_off;
	else if (!strcmp(argv[1], "toggle")) led_com_toggle;
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "ledact on/off/toggle"LINE_TERM);
	return;
}

static void smb_cmd_set_motiondebug (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;

	if (argc != 2) {
		goto USAGE;
	}

	if (!strcmp(argv[1], "on")) SBStatusObj.people_aroundObj.motion_debug = true;
	else if (!strcmp(argv[1], "off")) SBStatusObj.people_aroundObj.motion_debug = false;
	else goto USAGE;
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "motiondebug on/off"LINE_TERM);
	return;
}

static void smb_cmd_set_offduty (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	uint8_t Hours, Minutes;

	if (argc != 3) {
		goto USAGE;
	}

	Hours = (uint8_t)strtoul(argv[1], NULL, 10);
	Minutes = (uint8_t)strtoul(argv[2], NULL, 10);

	SBConfigObj.lamp_off_duty.Hours = Hours;
	SBConfigObj.lamp_off_duty.Minutes = Minutes;
	assert (duty_minutes_set(&SBStatusObj) == true);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "setoffduty 6 10 (for example 6:10 am)"LINE_TERM);
	return;
}

static void smb_cmd_set_onduty (SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv)
{
	const void* cmdIoParam = pCmdIO->cmdIoParam;
	uint8_t Hours, Minutes;

	if (argc != 3) {
		goto USAGE;
	}

	Hours = (uint8_t)strtoul(argv[1], NULL, 10);
	Minutes = (uint8_t)strtoul(argv[2], NULL, 10);

	SBConfigObj.lamp_on_duty.Hours = Hours;
	SBConfigObj.lamp_on_duty.Minutes = Minutes;
	assert (duty_minutes_set(&SBStatusObj) == true);
	return;

	USAGE:
	(*pCmdIO->pCmdApi->msg)(cmdIoParam, "setoffduty 6 10 (for example 6:10 am)"LINE_TERM);
	return;
}
#endif

static const SYS_CMD_DESCRIPTOR    bench_CommandTbl []=
{
		{"showbench",		smb_cmd_show_bench,		"\t\t- showbench"},
		{"sb",				smb_cmd_show_bench,		"\t\t\t- sb"},
		{"ledbar",			smb_cmd_set_ledbar,		"\t\t- ledbar off/red/green/blue/yellow/white"},
		{"siren",			smb_cmd_set_siren,		"\t\t- siren on/off"},
		{"lte",				smb_cmd_set_ltepwr,		"\t\t- lte on/off"},
		{"ptc",				smb_cmd_set_ptc,		"\t\t- ptc on/off"},
		{"yuchar",			smb_cmd_set_yuchar,		"\t\t- yuchar on/off"},
#if 0
		{"showadc",			smb_cmd_show_adc,		"\t\t- showadc"},
		{"charger",			smb_cmd_set_charger,	"\t\t- charger on/off"},
		{"inverter",		smb_cmd_set_inverter,	"\t\t- inverter on/off"},
		{"lcdpwr",			smb_cmd_set_lcdpwr,		"\t\t- lcdpwr on/off"},
		{"lamp",			smb_cmd_set_lamp,		"\t\t- lamp 0~9"},
		{"fan",				smb_cmd_set_fan,		"\t\t- fan on/off"},
		{"muchar1",			smb_cmd_set_muchar1,	"\t\t- muchar1 on/off"},
		{"muchar2",			smb_cmd_set_muchar2,	"\t\t- muchar2 on/off"},
		{"spare",			smb_cmd_set_spare,		"\t\t- spare 1/2/3/4/5 on/off"},
		{"ledact",			smb_cmd_set_ledact,		"\t\t- ledact on/off/toggle"},
		{"ledcom",			smb_cmd_set_ledcom,		"\t\t- ledcom on/off/toggle"},
		{"motiondebug",		smb_cmd_set_motiondebug,"\t- motiondebug on/off"},
		{"setoffduty",		smb_cmd_set_offduty,	"\t\t- setoffduty 6 10 (for example 6:10 am)"},
		{"setonduty",		smb_cmd_set_onduty,		"\t\t- setonduty 18 15 (for example 18:15 pm)"},
#endif

};

bool smb_cmd_bench_add ()
{
	assert (SYS_CMD_ADDGRP(bench_CommandTbl, sizeof(bench_CommandTbl)/sizeof(*bench_CommandTbl), "bench", ": bench command group") == true);
	return true;
}

