/**
 ******************************************************************************
 * File Name          : func_state_event.c
 * Description        : This file is generated by 위대한 송 인재 on Mar 31, 2025
 ******************************************************************************
 *
 * COPYRIGHT(c) 2024 DSN Co. Ltd.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *   1. Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *   3. Neither the name of STMicroelectronics nor the names of its contributors
 *      may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************
 */

#include "main.h"

static bool get_file_name_from_packet(iapObj_t *piapObj, soh_packet_t *yPacketp);
static bool get_file_size_from_packet(iapObj_t *piapObj, soh_packet_t *yPacketp);
static bool IsBootableImage(char *file_name);
static bool move_image_onto_flash_bank(char *file_name);
static bool switching_boot();
bool iapObj_init(iapObj_t *iapObjp);

static uint16_t UpdateCRC16(uint16_t crc_in, uint8_t byte);
/**
 * @brief  Update CRC16 for input byte
 * @param  crc_in input value
 * @param  input byte
 * @retval None
 */
static uint16_t UpdateCRC16(uint16_t crc_in, uint8_t byte)
{
	uint32_t crc = crc_in;
	uint32_t in = byte | 0x100;

	do {
		crc <<= 1;
		in <<= 1;
		if(in & 0x100)
			++crc;
		if(crc & 0x10000)
			crc ^= 0x1021;
	}

	while(!(in & 0x10000));

	return crc & 0xffffu;
}

/**
 * @brief  Cal CRC16 for YModem Packet
 * @param  data
 * @param  length
 * @retval None
 */
uint16_t Cal_CRC16(const uint8_t* p_data, uint32_t size)
{
	uint16_t crc = 0;
	const uint8_t* dataEnd = p_data+size;

	while(p_data < dataEnd) {
		crc = UpdateCRC16(crc, *p_data++);
	}

	crc = UpdateCRC16(crc, 0);
	crc = UpdateCRC16(crc, 0);

	return crc;
}


/**
 * @brief  Convert an Integer to a string
 * @param  p_str: The string output pointer
 * @param  intnum: The integer to be converted
 * @retval None
 */
void Int2Str(uint8_t *p_str, uint32_t intnum)
{
	uint32_t i, divider = 1000000000, pos = 0, status = 0;

	for (i = 0; i < 10; i++)
	{
		p_str[pos++] = (intnum / divider) + 48;

		intnum = intnum % divider;
		divider /= 10;
		if ((p_str[pos-1] == '0') & (status == 0))
		{
			pos = 0;
		}
		else
		{
			status++;
		}
	}
}

/**
 * @brief  Convert a string to an integer
 * @param  p_inputstr: The string to be converted
 * @param  p_intnum: The integer value
 * @retval 1: Correct
 *         0: Error
 */
uint32_t Str2Int(uint8_t *p_inputstr, uint32_t *p_intnum)
{
	uint32_t i = 0, res = 0;
	uint32_t val = 0;

	if ((p_inputstr[0] == '0') && ((p_inputstr[1] == 'x') || (p_inputstr[1] == 'X')))
	{
		i = 2;
		while ( ( i < 11 ) && ( p_inputstr[i] != '\0' ) )
		{
			if (ISVALIDHEX(p_inputstr[i]))
			{
				val = (val << 4) + CONVERTHEX(p_inputstr[i]);
			}
			else
			{
				/* Return 0, Invalid input */
				res = 0;
				break;
			}
			i++;
		}

		/* valid result */
		if (p_inputstr[i] == '\0')
		{
			*p_intnum = val;
			res = 1;
		}
	}
	else /* max 10-digit decimal input */
	{
		while ( ( i < 11 ) && ( res != 1 ) )
		{
			if (p_inputstr[i] == '\0')
			{
				*p_intnum = val;
				/* return 1 */
				res = 1;
			}
			else if (((p_inputstr[i] == 'k') || (p_inputstr[i] == 'K')) && (i > 0))
			{
				val = val << 10;
				*p_intnum = val;
				res = 1;
			}
			else if (((p_inputstr[i] == 'm') || (p_inputstr[i] == 'M')) && (i > 0))
			{
				val = val << 20;
				*p_intnum = val;
				res = 1;
			}
			else if (ISVALIDDEC(p_inputstr[i]))
			{
				val = val * 10 + CONVERTDEC(p_inputstr[i]);
			}
			else
			{
				/* return 0, Invalid input */
				res = 0;
				break;
			}
			i++;
		}
	}

	return res;
}

static bool get_file_name_from_packet(iapObj_t *piap_status, soh_packet_t *yPacketp)
{
	char *p;

	p = strcpy((char *)iapObj.file_name, (char *)&yPacketp->pkt_data[0]);
	if (p == NULL) return false;
	else {
		return true;
	}
}

static bool get_file_size_from_packet(iapObj_t *piap_status, soh_packet_t *yPacketp)
{
	uint8_t file_size[FILE_SIZE_LENGTH];
	uint8_t *p = &yPacketp->pkt_data[0];

	memset (file_size, 0, sizeof(file_size));
	for (uint32_t i = 0 ; i < FILE_NAME_LENGTH ; i++, p++) {
		if (*p == '\0') break;
	}
	p++;
	assert (*p != '\0');

	for (uint16_t index = 0 ; *p != 0x20 ; index++) {
		file_size[index] = *p++;
	}
	Str2Int(file_size, &iapObj.file_size);

	return true;
}

// Smart Bench 용 FW image 파일 이름은 SMB_ 로 시작해야만 한다.
static bool IsBootableImage(char *file_name)
{
	bool res;

	char bootable_file_header[] = "SMB_";
	res = strncmp (file_name, bootable_file_header, strlen(bootable_file_header));

	if (res == 0) return true;
	else return false;
}

static bool flash_other_bank_erase (uint32_t Bank)
{
	FLASH_EraseInitTypeDef EraseInit;
	uint32_t PageError;
	HAL_StatusTypeDef status;

	EraseInit.TypeErase = FLASH_TYPEERASE_MASSERASE;
	EraseInit.Banks = Bank;

	HAL_FLASH_Unlock();
	status = HAL_FLASHEx_Erase(&EraseInit, &PageError);
	HAL_FLASH_Lock();

	if (status != HAL_OK) {
		printf("%s() PageError = %#010"PRIx32 LINE_TERM, __FUNCTION__, PageError);
		return false;
	}

	return true;
}

#define	HAL_FLASH_Programming_WRITE_UNIT	256U		// HAL_FLASH_Program() 를 써야 하는데 이것은 256Byte 만 Write 하기 때문에 이렇게 한다.
static void flash_programming_progress_draw(lfs_size_t file_size, uint32_t progress_count)
{
	uint8_t programming_percentage = (progress_count * 100)/ file_size;
	printf(CUI_ESC_CUR_LINE, 5);
	for (uint32_t i  = 0 ; i < 100 ; i++) {
		if (i < programming_percentage) printf("#");
		else printf("_");
	}
	printf (" %3d%% (%ld)", programming_percentage, progress_count);
	osDelay(1);
	return;
}

static bool fw_upgrade_history_add(char file_name[])
{
	lfs_file_t file;
	char fw_update_string[100];
	int len = 0;
	assert (IsFS_mount == true);

	len += sprintf(&fw_update_string[0], "%s is updated on ", file_name);
	len += sprintf(&fw_update_string[len], "%4d/%2d/%2d %2d:%2d:%2d", \
			2000 + RTC_Bcd2ToByte(SMB_StatusObj.currentDate.Year), RTC_Bcd2ToByte(SMB_StatusObj.currentDate.Month), RTC_Bcd2ToByte(SMB_StatusObj.currentDate.Date), \
			RTC_Bcd2ToByte(SMB_StatusObj.currentTime.Hours), RTC_Bcd2ToByte(SMB_StatusObj.currentTime.Minutes), RTC_Bcd2ToByte(SMB_StatusObj.currentTime.Seconds));
	len += sprintf(&fw_update_string[len], LINE_TERM);

	assert (lfs_file_open(&lfs, &file, FW_UPGRADE_HISTORY_FILE, LFS_O_WRONLY | LFS_O_CREAT | LFS_O_APPEND) == LFS_ERR_OK);

	lfs_file_write(&lfs, &file, fw_update_string, len);
	assert (lfs_file_close(&lfs, &file) == LFS_ERR_OK);

	return true;
}

static bool move_image_onto_flash_bank(char *file_name)
{
	lfs_file_t file;
	struct lfs_info info;
	lfs_size_t file_size;
	void *pimage_256_piece = NULL;
	uint32_t Bank, image_size_written = 0, piece_size = 0, Dest_Flash_Address;
	uint64_t uint64_t_piece_address;

	assert (IsFS_mount == true);

	if (lfs_stat(&lfs, file_name, &info) != LFS_ERR_OK) {
		printf("No such file %s"LINE_TERM, file_name);
		return false;
	}

	file_size = info.size;
	assert (file_size < FLASH_SIZE/2);			// 내가 flash 를 bank1, bank2 로 쪼개서 쓰기 때문에 1 bank 는 512K 가 되고 image 는 512K 보다 작아야 한다.
	assert (file_size%PACKET_1K_SIZE == 0);		// STX packet 이 1024 단위로 오고 이것을 그대로 file 에 저장하기 때문에 file size 는 1024의 배수가 되어야 한다.

	pimage_256_piece = malloc (HAL_FLASH_Programming_WRITE_UNIT);
	assert (pimage_256_piece != NULL);

	Bank = (READ_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_FB_MODE) == 0)?FLASH_BANK_2:FLASH_BANK_1;
	assert (flash_other_bank_erase(Bank) == true);

	assert (lfs_file_open(&lfs, &file, file_name, LFS_O_RDONLY) == LFS_ERR_OK);
	Dest_Flash_Address = (uint32_t)(FLASH_BASE + FLASH_BANK_SIZE);		// Bank_2 에서 running 중이라 하더라도 other side bank 의 address 는 항상 FLASH_BASE + FLASH_BANK_SIZE 으로 보인다.
	// 아래는 pimage_256_piece 를 사용해서 작업하는 구간..반드시 free() 하고 나가야 하므로 중간에 return 은 없다.
	uint64_t_piece_address = (uint64_t)((uint32_t)pimage_256_piece);	// HAL_FLASH_Program() 의 3번째 인수가 uint64_t 형을 요구하기 때문에 compile warning 을 피하기 위해 이런 짓을 함.
	for (uint32_t i = 0; i < file_size ; i += HAL_FLASH_Programming_WRITE_UNIT) {
		memset (pimage_256_piece, 0, HAL_FLASH_Programming_WRITE_UNIT);
		piece_size = lfs_file_read(&lfs, &file, pimage_256_piece, HAL_FLASH_Programming_WRITE_UNIT);
		if ((i % (HAL_FLASH_Programming_WRITE_UNIT*20)) == 0) flash_programming_progress_draw(file_size, i);
		HAL_FLASH_Unlock();
		assert (HAL_FLASH_Program(FLASH_TYPEPROGRAM_FAST, Dest_Flash_Address, (uint64_t)uint64_t_piece_address) == HAL_OK);
		HAL_FLASH_Lock();
		Dest_Flash_Address += HAL_FLASH_Programming_WRITE_UNIT;
		image_size_written += piece_size;
		osDelay(2);
	}

	flash_programming_progress_draw(file_size, file_size);		// To display "100%"
	HAL_FLASH_Unlock();
	assert (HAL_FLASH_Program(FLASH_TYPEPROGRAM_FAST_AND_LAST, Dest_Flash_Address, (uint64_t)uint64_t_piece_address) == HAL_OK);
	HAL_FLASH_Lock();
	printf(LINE_TERM);
	osDelay(1);
	assert (file_size == image_size_written);
	assert (lfs_file_close(&lfs, &file) == LFS_ERR_OK);
	free(pimage_256_piece);
	assert (fw_upgrade_history_add(file_name) == true);
	return true;
}

static bool switching_boot()
{
	FLASH_OBProgramInitTypeDef OB;
	uint32_t sr;

	// 혹시라도 FLASH->SR 에 error 가 표시되어 있으면 switching boot 할 때 실패하기 때문에 이런 작업을 한다.
	sr = READ_REG(FLASH->SR);
	if (sr != 0) WRITE_REG(FLASH->SR, sr);
	assert (READ_REG(FLASH->SR) == 0);

	memset (&OB, 0, sizeof(OB));
	HAL_FLASHEx_OBGetConfig(&OB);

	OB.OptionType = OPTIONBYTE_USER;
	OB.USERType = OB_USER_BFB2;
	if ((OB.USERConfig & FLASH_OPTR_BFB2_Msk) == FLASH_OPTR_BFB2) {
		OB.USERConfig &= ~FLASH_OPTR_BFB2;
	}
	else {
		OB.USERConfig |= FLASH_OPTR_BFB2;
	}

	assert (HAL_FLASH_Unlock() == HAL_OK);
	assert (HAL_FLASH_OB_Unlock() == HAL_OK);
	assert (HAL_FLASHEx_OBProgram(&OB) == HAL_OK);
	assert (HAL_FLASH_OB_Launch() == HAL_OK);	// HAL_FLASH_OB_Launch() 는 system reset 을 발생시켜서 이후 루틴은 수행되지 않는다.
	assert (HAL_FLASH_OB_Lock() == HAL_OK);
	assert (HAL_FLASH_Lock() == HAL_OK);

	return true;
}

static bool ypkt_se_machine_func_default(ymodem_packet_t *ymp, uint16_t pkt_len)
{
	printf("%s()"LINE_TERM, __FUNCTION__);
	//	정상 state/event 에서 벗어나면 무조건 cancel 한다.
	//	Serial_PutByte(CA);
	// 지금은 test 용
	Serial_PutByte(NAK);
	return true;
}

static bool iap_file_create(char path[])
{
	struct lfs_info info;
	if (lfs_stat(&lfs, path, &info) == LFS_ERR_OK) {		// 동일한 이름의 파일이 이미 존재하고 있다면 기존 파일을 먼저 지운다.
		assert (lfs_remove(&lfs, path) == LFS_ERR_OK);
	}
	assert (lfs_file_open(&lfs, &iapObj.file, path, LFS_O_RDWR | LFS_O_CREAT) == LFS_ERR_OK);
	assert (lfs_file_close(&lfs, &iapObj.file) == LFS_ERR_OK);

	return true;
}

static bool iap_file_handler(char path[], void *image, uint16_t len)
{
	lfs_soff_t offset;

	assert (len != 0);
	assert (image != NULL);

	assert (lfs_file_open(&lfs, &iapObj.file, path, LFS_O_RDWR | LFS_O_CREAT) == LFS_ERR_OK);
	offset = lfs_file_size(&lfs, &iapObj.file);
	//	printf ("offset = %lu"LINE_TERM, offset);		// 1024Byte 단위로 증가하는 것 확인.
	assert (lfs_file_seek(&lfs, &iapObj.file, offset, 0) == offset);	// 파일의 끝을 찾아서 새로 받은 packet 을 size 만큼 write 해준다.
	assert (lfs_file_write(&lfs, &iapObj.file, image, len) == len);
	assert (lfs_file_close(&lfs, &iapObj.file) == LFS_ERR_OK);

	return true;
}

// *****************************************************************************
// iapObj.iap_state == IAP_STATE_SOH
// *****************************************************************************
static bool s_SOH_soh_handler(ymodem_packet_t *ymp, uint16_t pkt_len)
{
	assert (iapObj_init(&iapObj) == true);
	//	assert (pkt_len == SOH_PACKET_SIZE);
	// 이렇게 하면 SOH packet 이 깨지는 경우에 대한 대비가 없어서 발생하면 시스템이 죽어버린다...
	if (pkt_len != SOH_PACKET_SIZE) {
		assert (osTimerList[TMR_IDX_SMB_IAP_REQUEST].osTimerId != NULL);
		assert (osTimerStop(osTimerList[TMR_IDX_SMB_IAP_REQUEST].osTimerId) == osOK);
		assert (osTimerStart(osTimerList[TMR_IDX_SMB_IAP_REQUEST].osTimerId, SOH_REQ_TIMEOUT) == osOK);
		return true;
	}
	// 이렇게 하면 SOH packet 이 깨지는 경우에 대한 대비가 없어서 발생하면 시스템이 죽어버린다...

	assert (get_file_size_from_packet(&iapObj, (soh_packet_t *)ymp) == true);

	if (iapObj.file_size > 512*1024) {		// STM32L496 의 flash size 는 1MB 이지만 내가 bank 를 2개로 쪼개 쓰기 때문에 512KB 이하라야 한다.
		Serial_PutByte(CA);
		return true;
	}
	assert (get_file_name_from_packet(&iapObj, (soh_packet_t *)ymp) == true);
	assert (ymp->seq == 0);
	iapObj.seq_no = ymp->seq;
	printf(CUI_ESC_CLR);
	printf(CUI_ESC_CUR_HOME);
	printf(CUI_ESC_CUR_HIDE);
	printf("file_name = %s (%ld Byte)"LINE_TERM, iapObj.file_name, iapObj.file_size);
	iapObj.iap_state = IAP_STATE_STX;
	iapObj.total_packet_count = iapObj.file_size/PACKET_1K_SIZE;
	assert (iap_file_create(iapObj.file_name) == true);		// 여기서는 파일 생성만 해둔다.
	Serial_PutByte(ACK);
	Serial_PutByte(CRC16);				// 명령어로 시험해본 결과 SOH 받고 나면 ACK 후에 CRC16 이 나가야만 STX 가 오기 시작한다..
	return true;
}

static bool s_SOH_stx_handler(ymodem_packet_t *ymp, uint16_t pkt_len)
{
	printf("%s() pkt_len = %d"LINE_TERM, __FUNCTION__, pkt_len);
	assert (iapObj_init(&iapObj) == true);
	Serial_PutByte(CA);
	return true;
}

static bool s_SOH_can_handler(ymodem_packet_t *ymp, uint16_t pkt_len)
{
	printf("%s() pkt_len = %d"LINE_TERM, __FUNCTION__, pkt_len);
	assert (iapObj_init(&iapObj) == true);
	Serial_PutByte(ACK);
	return true;
}

static bool s_SOH_eot_handler(ymodem_packet_t *ymp, uint16_t pkt_len)
{
	printf("%s() pkt_len = %d"LINE_TERM, __FUNCTION__, pkt_len);
	assert (iapObj_init(&iapObj) == true);
	Serial_PutByte(ACK);
	return true;
}

static bool s_SOH_split_handler(ymodem_packet_t *ymp, uint16_t pkt_len)
{
	printf("%s() pkt_len = %d"LINE_TERM, __FUNCTION__, pkt_len);
	iapObj.soh_byte_counter += pkt_len;

	if (iapObj.soh_byte_counter >= SOH_PACKET_SIZE) {
		iapObj.soh_byte_counter = 0;
		Serial_PutByte(NAK);
	}
	else {
		// 작게 쪼개져서 들어오는 경우는 계속 packet 이  이어져야 하기 때문에 아무 동작도 하지 않는다. 위에서 1개의 SOH packet 이 모두 완료된 경우에 NAK 를 보내서 해당 packet 을 재전송하게 한다.
	}

	return true;
}

// *****************************************************************************
// iapObj.iap_state == IAP_STATE_STX
// *****************************************************************************
static bool s_STX_soh_handler(ymodem_packet_t *ymp, uint16_t pkt_len)
{
	printf("%s() pkt_len = %d"LINE_TERM, __FUNCTION__, pkt_len);
	assert (iapObj_init(&iapObj) == true);
	Serial_PutByte(CA);
	return true;
}

static void download_progress_draw(iapObj_t *piapObj, uint32_t seq_no)
{
	uint8_t download_percentage = (seq_no * 100)/ piapObj->total_packet_count;
	printf(CUI_ESC_CUR_LINE, 3);
	for (uint32_t i  = 0 ; i < 100 ; i++) {
		if (i < download_percentage) printf("#");
		else printf("_");
	}
	printf (" %3d%% (%ld)", download_percentage, seq_no);
	return;
}

static bool s_STX_stx_handler(ymodem_packet_t *ymp, uint16_t pkt_len)
{
	stx_packet_t *pstx_packet = (stx_packet_t *)ymp;

	iapObj.iap_progress_counter++;
	download_progress_draw(&iapObj, iapObj.iap_progress_counter);
	uint8_t sequence_no = iapObj.seq_no + 1;
	assert (sequence_no == ymp->seq);
	iapObj.seq_no = ymp->seq;		// 0->1->2->3-> ..... ->254->255->0 으로 뺑뺑이 돈다.
	iapObj.iap_state = IAP_STATE_STX;
	iapObj.stx_byte_counter = 0;
	assert (iap_file_handler(iapObj.file_name, (void *)pstx_packet->pkt_data, YMODEM_STX_PKT_DATA_SIZE) == true);		// 여기서는 파일에 실제로 write 한다.
	Serial_PutByte(ACK);
	return true;
}

static bool s_STX_can_handler(ymodem_packet_t *ymp, uint16_t pkt_len)
{
	printf("%s() pkt_len = %d"LINE_TERM, __FUNCTION__, pkt_len);
	assert (iapObj_init(&iapObj) == true);
	Serial_PutByte(ACK);
	return true;
}

static bool s_STX_eot_handler(ymodem_packet_t *ymp, uint16_t pkt_len)
{
	printf(CUI_ESC_CUR_SHOW);
	iapObj.iap_state = IAP_STATE_SOH;
	Serial_PutByte(ACK);
	Serial_PutByte(ACK);

	// 파일 check 후 other bank 에 써주고 나서 switch 를 한다. 만일 파일이 깨졌다면 재전송하도록 다시 초기상태로 back 한다.
	if (IsBootableImage(iapObj.file_name) == true) {
		if (move_image_onto_flash_bank (iapObj.file_name) == true) switching_boot();
		else printf("move_image_onto_flash_bank(%s) false"LINE_TERM, iapObj.file_name);
	}
	else {
		printf(LINE_TERM"The file %s loading is finished.."LINE_TERM, iapObj.file_name);
	}

	assert (iapObj_init(&iapObj) == true);
	return true;
}

static bool s_STX_split_handler(ymodem_packet_t *ymp, uint16_t pkt_len)
{
	iapObj.stx_byte_counter += pkt_len;

	if (iapObj.stx_byte_counter >= STX_PACKET_SIZE) {
		iapObj.stx_byte_counter = 0;
		Serial_PutByte(NAK);
	}
	else {
		// 작게 쪼개져서 들어오는 경우는 계속 packet 이  이어져야 하기 때문에 아무 동작도 하지 않는다. 위에서 1개의 STX packet 이 모두 완료된 경우에 NAK 를 보내서 해당 packet 을 재전송하게 한다.
	}
	return true;
}

// *****************************************************************************
// state-event machine 초기화
// *****************************************************************************
bool iap_se_machine_init()
{
	for (uint32_t i = 0 ; i < IAP_STATE_END ; i++) {
		for (uint32_t j = 0 ; j < YPKT_EVENT_END ; j++) {
			iap_se_machine[i][j] = ypkt_se_machine_func_default;
		}
	}

	iap_se_machine[IAP_STATE_SOH][YPKT_EVENT_SOH] = s_SOH_soh_handler;
	iap_se_machine[IAP_STATE_SOH][YPKT_EVENT_STX] = s_SOH_stx_handler;
	iap_se_machine[IAP_STATE_SOH][YPKT_EVENT_CAN] = s_SOH_can_handler;
	iap_se_machine[IAP_STATE_SOH][YPKT_EVENT_EOT] = s_SOH_eot_handler;
	iap_se_machine[IAP_STATE_SOH][YPKT_EVENT_SPL] = s_SOH_split_handler;

	iap_se_machine[IAP_STATE_STX][YPKT_EVENT_SOH] = s_STX_soh_handler;
	iap_se_machine[IAP_STATE_STX][YPKT_EVENT_STX] = s_STX_stx_handler;
	iap_se_machine[IAP_STATE_STX][YPKT_EVENT_CAN] = s_STX_can_handler;
	iap_se_machine[IAP_STATE_STX][YPKT_EVENT_EOT] = s_STX_eot_handler;
	iap_se_machine[IAP_STATE_STX][YPKT_EVENT_SPL] = s_STX_split_handler;

	return true;
}
