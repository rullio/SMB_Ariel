/**
 ******************************************************************************
 * File Name          : func_rb_cmds.c
 * Description        : This file is generated by 위대한 송 인재 on Mar 14, 2025
 ******************************************************************************
 *
 * COPYRIGHT(c) 2024 DSN Co. Ltd.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *   1. Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *   3. Neither the name of STMicroelectronics nor the names of its contributors
 *      may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************
 */

#include "main.h"

typedef bool (* rb_cmd_func)(rb_command_t *);
static rb_cmd_func				rb_cmd_handler_tbl[RB_HEAD_TYPE_MAX];

static bool rb_cmd_handler_default(rb_command_t *rb_cmdp)
{
	printf("%s() : rb_command"LINE_TERM, __FUNCTION__);
	printf("type = 0x%2x"LINE_TERM, rb_cmdp->type);
	printf("len = 0x%2x"LINE_TERM, rb_cmdp->len);
	printf("body[0] = 0x%2x"LINE_TERM, rb_cmdp->body[0]);
	printf("body[1] = 0x%2x"LINE_TERM, rb_cmdp->body[1]);
	printf("body[2] = 0x%2x"LINE_TERM, rb_cmdp->body[2]);
	printf("body[3] = 0x%2x"LINE_TERM, rb_cmdp->body[3]);
	printf("checksum = 0x%2x"LINE_TERM, rb_cmdp->checksum);
	printf("end_marker = 0x%2x"LINE_TERM, rb_cmdp->end_marker);

	return true;
}

bool RB_INFO_RB_WORK_BEGIN_handler(rb_command_t *rb_cmdp)
{
	printf("%s()"LINE_TERM, __FUNCTION__);
	SMB_StatusObj.rb_working = true;
	sb_report_to_rb(RB_REPORT_HW_VERSION, SMB_StatusObj.hw_version);
	return true;
}

bool RB_INFO_RB_WORK_HALT_handler(rb_command_t *rb_cmdp)
{
	printf("%s()"LINE_TERM, __FUNCTION__);
	SMB_StatusObj.rb_working = false;
	return true;
}

bool RB_CMD_SENSOR_RESET_handler(rb_command_t *rb_cmdp)
{
	printf(LINE_TERM"====== SYSTEM RESET by GUI ======="LINE_TERM);
	printf(CUI_ESC_CLR);
	printf(CUI_ESC_CUR_HOME);
	HAL_Delay(4);
	doSystemReset();
	while(1) {};

	return true;
}

bool RB_CMD_LEDBAR_handler(rb_command_t *rb_cmdp)
{
	printf("%s() ", __FUNCTION__);
	switch ((ledbar_color_t)rb_cmdp->body[0]) {
	case LEDBAR_OFF :		printf("LEDBAR_OFF"LINE_TERM); break;
	case LEDBAR_RED :		printf("LEDBAR_RED"LINE_TERM); break;
	case LEDBAR_YELLOW :	printf("LEDBAR_YELLOW"LINE_TERM); break;
	case LEDBAR_GREEN : 	printf("LEDBAR_GREEN"LINE_TERM); break;
	case LEDBAR_BLUE : 		printf("LEDBAR_BLUE"LINE_TERM); break;
	case LEDBAR_WHITE : 	printf("LEDBAR_WHITE"LINE_TERM); break;
	default : assert (0 == 1); break;
	}

	SMB_ControlObj.ledbarObj.ledbar_color_set((ledbar_color_t)rb_cmdp->body[0]);
	return true;
}

bool smb_manipulation_begin (void)
{
	SMB_StatusObj.smb_manipulation = true;
	assert (osTimerList[TMR_IDX_SMB_MANIPULATION].osTimerId != NULL);
	assert (osTimerStart(osTimerList[TMR_IDX_SMB_MANIPULATION].osTimerId, SMB_MANIPULATION_TIMEOUT) == osOK);
	return true;
}

bool RB_MANIPULATE_LEDBAR_handler(rb_command_t *rb_cmdp)
{
	printf("%s() "LINE_TERM, __FUNCTION__);
	switch ((ledbar_color_t)rb_cmdp->body[0]) {
	case LEDBAR_OFF :		printf("LEDBAR_OFF"LINE_TERM); break;
	case LEDBAR_RED :		printf("LEDBAR_RED"LINE_TERM); break;
	case LEDBAR_YELLOW :	printf("LEDBAR_YELLOW"LINE_TERM); break;
	case LEDBAR_GREEN : 	printf("LEDBAR_GREEN"LINE_TERM); break;
	case LEDBAR_BLUE : 		printf("LEDBAR_BLUE"LINE_TERM); break;
	case LEDBAR_WHITE : 	printf("LEDBAR_WHITE"LINE_TERM); break;
	default : assert (0 == 1); break;
	}

	SMB_ControlObj.ledbarObj.ledbar_color_set((ledbar_color_t)rb_cmdp->body[0]);
	smb_manipulation_begin();
	return true;
}

bool RB_MANIPULATE_SIREN_handler(rb_command_t *rb_cmdp)
{
	printf("%s() : %s"LINE_TERM, __FUNCTION__, (rb_cmdp->body[0] == 1)?"ON":"OFF");

	if (rb_cmdp->body[0] == 1) SMB_ControlObj.sirenObj.siren_set(SIREN_ON);
	else SMB_ControlObj.sirenObj.siren_set(SIREN_OFF);

	smb_manipulation_begin();
	return true;
}

bool RB_MANIPULATE_LTE_PWR_handler(rb_command_t *rb_cmdp)
{
	printf("%s() : %s"LINE_TERM, __FUNCTION__, (rb_cmdp->body[0] == 1)?"ON":"OFF");

//	 LTE 조절 금지..
//	if (rb_cmdp->body[0] == 1) SMB_ControlObj.lteObj.lte_set(LTE_ON);
//	else SMB_ControlObj.lteObj.lte_set(LTE_OFF);
//
//	smb_manipulation_begin();
	return true;
}

bool RB_MANIPULATE_CHARGER_handler(rb_command_t *rb_cmdp)
{

	smb_manipulation_begin();
	return true;
}

bool RB_MANIPULATE_INVERTER_handler(rb_command_t *rb_cmdp)
{
	printf("%s() : %s"LINE_TERM, __FUNCTION__, (rb_cmdp->body[0] == 1)?"ON":"OFF");
	if (rb_cmdp->body[0] == 1) SMB_ControlObj.inverterObj.inverter_set(INVERTER_ON);
	else SMB_ControlObj.inverterObj.inverter_set(INVERTER_OFF);

	smb_manipulation_begin();
	return true;
}

bool RB_MANIPULATE_LCD_PWR_handler(rb_command_t *rb_cmdp)
{
	printf("%s() : %s"LINE_TERM, __FUNCTION__, (rb_cmdp->body[0] == 1)?"ON":"OFF");

	if (rb_cmdp->body[0] == 1) SMB_ControlObj.lcdObj.lcd_set(LCD_ON);
	else SMB_ControlObj.lcdObj.lcd_set(LCD_OFF);

	smb_manipulation_begin();
	return true;
}

bool RB_MANIPULATE_PTC_handler(rb_command_t *rb_cmdp)
{
	printf("%s() : %s"LINE_TERM, __FUNCTION__, (rb_cmdp->body[0] == 1)?"ON":"OFF");
	if (rb_cmdp->body[0] == 1) SMB_ControlObj.ptcObj.ptc_set(PTC_ON);
	else SMB_ControlObj.ptcObj.ptc_set(PTC_OFF);

	smb_manipulation_begin();
	return true;
}

bool RB_MANIPULATE_LAMP_handler(rb_command_t *rb_cmdp)
{
	printf("%s() : %s"LINE_TERM, __FUNCTION__, (rb_cmdp->body[0] == 1)?"ON":"OFF");
	if (rb_cmdp->body[0] == 1) SMB_ControlObj.lampObj.lamp_set(LAMP_LEVEL_9);
	else SMB_ControlObj.lampObj.lamp_set(LAMP_LEVEL_0);

	smb_manipulation_begin();
	return true;
}

bool RB_MANIPULATE_YUCHAR_handler(rb_command_t *rb_cmdp)
{
	printf("%s() : %s"LINE_TERM, __FUNCTION__, (rb_cmdp->body[0] == 1)?"ON":"OFF");
	if (rb_cmdp->body[0] == 1) SMB_ControlObj.yucharObj.yuchar_set(YUCHAR_ON);
	else SMB_ControlObj.yucharObj.yuchar_set(YUCHAR_OFF);

	smb_manipulation_begin();
	return true;
}

bool RB_MANIPULATE_MUCHAR1_handler(rb_command_t *rb_cmdp)
{
	printf("%s() : %s"LINE_TERM, __FUNCTION__, (rb_cmdp->body[0] == 1)?"ON":"OFF");
	if (rb_cmdp->body[0] == 1) SMB_ControlObj.muchar1Obj.muchar1_set(MUCHAR_ON);
	else SMB_ControlObj.muchar1Obj.muchar1_set(MUCHAR_OFF);

	smb_manipulation_begin();
	return true;
}

bool RB_MANIPULATE_MUCHAR2_handler(rb_command_t *rb_cmdp)
{
	printf("%s() : %s"LINE_TERM, __FUNCTION__, (rb_cmdp->body[0] == 1)?"ON":"OFF");
	if (rb_cmdp->body[0] == 1) SMB_ControlObj.muchar2Obj.muchar2_set(MUCHAR_ON);
	else SMB_ControlObj.muchar2Obj.muchar2_set(MUCHAR_OFF);

	smb_manipulation_begin();
	return true;
}

bool RB_MANIPULATE_FAN_handler(rb_command_t *rb_cmdp)
{
	printf("%s() : %s"LINE_TERM, __FUNCTION__, (rb_cmdp->body[0] == 1)?"ON":"OFF");
	if (rb_cmdp->body[0] == 1) SMB_ControlObj.fanObj.fan_set(FAN_ON);
	else SMB_ControlObj.fanObj.fan_set(FAN_OFF);

	smb_manipulation_begin();
	return true;
}

bool RB_REPORT_SENSOR_STATUS_handler(rb_command_t *rb_cmdp)
{
//	printf("%s() "LINE_TERM, __FUNCTION__);
	sb_report_to_rb(RB_REPORT_SENSOR_STATUS, 0);
	sb_report_to_rb(RB_REPORT_YUIW,			(uint32_t)SMB_adc_value.YUI);
	sb_report_to_rb(RB_REPORT_MUI1W,		(uint32_t)SMB_adc_value.MUI1);
	sb_report_to_rb(RB_REPORT_MUI2W,		(uint32_t)SMB_adc_value.MUI2);
	sb_report_to_rb(RB_REPORT_AEDT,			(uint32_t)SMB_adc_value.AEDT);
	sb_report_to_rb(RB_REPORT_CDS,			(uint32_t)SMB_adc_value.CDS);
	sb_report_to_rb(RB_REPORT_LEDBAR_COLOR,	(uint32_t)SMB_ControlObj.ledbarObj.ledbar_color);
	return true;
}

bool RB_CONFIG_UNIX_DATE_handler(rb_command_t *rb_cmdp)
{
	RTC_DateTypeDef sDate;
	uint8_t Year, Month, Date;

	printf("%s() : %d:%d:%d:%d"LINE_TERM, __FUNCTION__, rb_cmdp->body[0], rb_cmdp->body[1], rb_cmdp->body[2], rb_cmdp->body[3]);

	Year = rb_cmdp->body[0];
	Month = rb_cmdp->body[1]+1;
	Date = rb_cmdp->body[2];

	if (Year > 99) {
		assert (0 == 1);
		return false;
	}

	if (Month > 12) {
		assert (0 == 1);
		return false;
	}

	if (Date > 31) {
		assert (0 == 1);
		return false;
	}

	sDate.Year = RTC_ByteToBcd2(Year);
	sDate.Month = RTC_ByteToBcd2(Month);
	sDate.Date = RTC_ByteToBcd2(Date);
	sDate.WeekDay = RTC_WEEKDAY_SUNDAY;		// GUI 에서 요일은 주지 않기 때문에 그냥 일요일로 설정한다.

	assert (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) == HAL_OK);

	return true;
}

bool RB_CONFIG_UNIX_TIME_handler(rb_command_t *rb_cmdp)
{
	uint8_t Hours, Minutes, Seconds;

	printf("%s() "LINE_TERM, __FUNCTION__);
	printf("%s() : %d:%d:%d:%d"LINE_TERM, __FUNCTION__, rb_cmdp->body[0], rb_cmdp->body[1], rb_cmdp->body[2], rb_cmdp->body[3]);

	Hours = (uint8_t)rb_cmdp->body[0];
	Minutes = (uint8_t)rb_cmdp->body[1];
	Seconds = (uint8_t)rb_cmdp->body[2];

	if (Hours > 23) {
		assert (0 == 1);
		return false;
	}
	if (Minutes > 59) {
		assert (0 == 1);
		return false;
	}
	if (Seconds > 59) {
		assert (0 == 1);
		return false;
	}

	RTC_TimeTypeDef sTime;
	sTime.Hours = RTC_ByteToBcd2(Hours);
	sTime.Minutes = RTC_ByteToBcd2(Minutes);
	sTime.Seconds = RTC_ByteToBcd2(Seconds);
	sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
	sTime.StoreOperation = RTC_STOREOPERATION_RESET;

	assert (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) == HAL_OK);

	//	SB_1sec_alarm_restart();
	//	assert (duty_minutes_set(&SBStatusObj) == true);

	return true;
}

/***********************************************************************************************************************
 *
 *
 * save_smb_configObj_onto_fs() 를 call 하는 모든 thread 는 app_entry() 에서 stack size 를 32 로 키워 주어야만 한다..
 * save_smb_configObj_onto_fs() 를 call 하는 모든 thread 는 app_entry() 에서 stack size 를 32 로 키워 주어야만 한다..
 * save_smb_configObj_onto_fs() 를 call 하는 모든 thread 는 app_entry() 에서 stack size 를 32 로 키워 주어야만 한다..
 * save_smb_configObj_onto_fs() 를 call 하는 모든 thread 는 app_entry() 에서 stack size 를 32 로 키워 주어야만 한다..
 * save_smb_configObj_onto_fs() 를 call 하는 모든 thread 는 app_entry() 에서 stack size 를 32 로 키워 주어야만 한다..
 * save_smb_configObj_onto_fs() 를 call 하는 모든 thread 는 app_entry() 에서 stack size 를 32 로 키워 주어야만 한다..
 * save_smb_configObj_onto_fs() 를 call 하는 모든 thread 는 app_entry() 에서 stack size 를 32 로 키워 주어야만 한다..
 * save_smb_configObj_onto_fs() 를 call 하는 모든 thread 는 app_entry() 에서 stack size 를 32 로 키워 주어야만 한다..
 * save_smb_configObj_onto_fs() 를 call 하는 모든 thread 는 app_entry() 에서 stack size 를 32 로 키워 주어야만 한다..
 * save_smb_configObj_onto_fs() 를 call 하는 모든 thread 는 app_entry() 에서 stack size 를 32 로 키워 주어야만 한다..
 *
 *
***********************************************************************************************************************/
bool save_smb_configObj_onto_fs(SMB_ConfigObj_t *pconfig)
{
	lfs_file_t file;
	uint32_t calculated_crc;

	assert (lfs_file_open(&lfs, &file, CONFIG_FILE_NAME, LFS_O_RDWR | LFS_O_CREAT) == LFS_ERR_OK);
	assert (lfs_file_write(&lfs, &file, pconfig, sizeof(SMB_ConfigObj_t)) == sizeof(SMB_ConfigObj_t));
	assert (lfs_file_close(&lfs, &file) == LFS_ERR_OK);

	// 새로 만든 config 파일의 crc 를 계산해서 crc 파일을 만들어 준다..
	assert (HAL_CRC_GetState(&hcrc)== HAL_CRC_STATE_READY);
	calculated_crc = HAL_CRC_Calculate(&hcrc, (uint32_t *)pconfig, sizeof(SMB_ConfigObj_t));
	printf("%s() Newly generated crc = %lx"LINE_TERM, __FUNCTION__, calculated_crc);

	assert (lfs_file_open(&lfs, &file, CONFIG_CRC_FILE_NAME, LFS_O_RDWR | LFS_O_CREAT) == LFS_ERR_OK);
	assert (lfs_file_write(&lfs, &file, (void *)&calculated_crc, sizeof(calculated_crc)) == sizeof(calculated_crc));
	assert (lfs_file_close(&lfs, &file) == LFS_ERR_OK);

	return true;
}

bool RB_CONFIG_SIREN_ON_DURATION_handler(rb_command_t *rb_cmdp)
{
	printf("%s() : %d:%d:%d:%d"LINE_TERM, __FUNCTION__, rb_cmdp->body[0], rb_cmdp->body[1], rb_cmdp->body[2], rb_cmdp->body[3]);
	SMB_ConfigObj.siren_on_time = (uint32_t)rb_cmdp->body[0];
	save_smb_configObj_onto_fs(&SMB_ConfigObj);
	return true;
}

bool RB_CONFIG_MOTION_LATENCY_handler(rb_command_t *rb_cmdp)
{
	printf("%s() : %d:%d:%d:%d"LINE_TERM, __FUNCTION__, rb_cmdp->body[0], rb_cmdp->body[1], rb_cmdp->body[2], rb_cmdp->body[3]);
	SMB_ConfigObj.motion_latency = (uint32_t)rb_cmdp->body[0];
	save_smb_configObj_onto_fs(&SMB_ConfigObj);

	return true;
}

bool RB_CONFIG_OFF_DUTY_TIME_handler(rb_command_t *rb_cmdp)
{
	printf("%s() : %d:%d:%d:%d"LINE_TERM, __FUNCTION__, rb_cmdp->body[0], rb_cmdp->body[1], rb_cmdp->body[2], rb_cmdp->body[3]);

	assert (rb_cmdp->body[0] < 23);
	assert (rb_cmdp->body[1] < 59);
	SMB_ConfigObj.lamp_off_duty.Hours = rb_cmdp->body[0];
	SMB_ConfigObj.lamp_off_duty.Minutes = rb_cmdp->body[1];
	save_smb_configObj_onto_fs(&SMB_ConfigObj);

	return true;
}

bool RB_CONFIG_ON_DUTY_TIME_handler(rb_command_t *rb_cmdp)
{
	printf("%s() : %d:%d:%d:%d"LINE_TERM, __FUNCTION__, rb_cmdp->body[0], rb_cmdp->body[1], rb_cmdp->body[2], rb_cmdp->body[3]);
	assert (rb_cmdp->body[0] < 23);
	assert (rb_cmdp->body[1] < 59);
	SMB_ConfigObj.lamp_on_duty.Hours = rb_cmdp->body[0];
	SMB_ConfigObj.lamp_on_duty.Minutes = rb_cmdp->body[1];
	save_smb_configObj_onto_fs(&SMB_ConfigObj);

	return true;
}

bool rb_command_handler_tbl_init()
{
	for (uint32_t i = RB_HEAD_TYPE_BASE ; i < RB_HEAD_TYPE_MAX ; i++) {
		rb_cmd_handler_tbl[i] = rb_cmd_handler_default;
	}
	// RB 에서 내려오는 것들..
	rb_cmd_handler_tbl[RB_INFO_RB_WORK_BEGIN]		= RB_INFO_RB_WORK_BEGIN_handler;
	rb_cmd_handler_tbl[RB_INFO_RB_WORK_HALT]		= RB_INFO_RB_WORK_HALT_handler;
	rb_cmd_handler_tbl[RB_CMD_SENSOR_RESET]			= RB_CMD_SENSOR_RESET_handler;
	//  RB thread 에서 timeout 에 의해 오는 것이지만 RB 에서 상태요청을 하는 RB_CMD_SENSOR_STATUS 명령을 받았을 때와 동일하게 처리한다.
	rb_cmd_handler_tbl[RB_CMD_SENSOR_STATUS]		= RB_REPORT_SENSOR_STATUS_handler;
	rb_cmd_handler_tbl[RB_CMD_LEDBAR]				= RB_CMD_LEDBAR_handler;
	rb_cmd_handler_tbl[RB_MANIPULATE_LEDBAR]		= RB_MANIPULATE_LEDBAR_handler;
	rb_cmd_handler_tbl[RB_MANIPULATE_SIREN]			= RB_MANIPULATE_SIREN_handler;
	rb_cmd_handler_tbl[RB_MANIPULATE_LTE_PWR]		= RB_MANIPULATE_LTE_PWR_handler;
	rb_cmd_handler_tbl[RB_MANIPULATE_CHARGER]		= RB_MANIPULATE_CHARGER_handler;
	rb_cmd_handler_tbl[RB_MANIPULATE_INVERTER]		= RB_MANIPULATE_INVERTER_handler;
	rb_cmd_handler_tbl[RB_MANIPULATE_LCD_PWR]		= RB_MANIPULATE_LCD_PWR_handler;
	rb_cmd_handler_tbl[RB_MANIPULATE_PTC]			= RB_MANIPULATE_PTC_handler;
	rb_cmd_handler_tbl[RB_MANIPULATE_LAMP]			= RB_MANIPULATE_LAMP_handler;
	rb_cmd_handler_tbl[RB_MANIPULATE_YUCHAR]		= RB_MANIPULATE_YUCHAR_handler;
	rb_cmd_handler_tbl[RB_MANIPULATE_MUCHAR1]		= RB_MANIPULATE_MUCHAR1_handler;
	rb_cmd_handler_tbl[RB_MANIPULATE_MUCHAR2]		= RB_MANIPULATE_MUCHAR2_handler;
	rb_cmd_handler_tbl[RB_MANIPULATE_FAN]			= RB_MANIPULATE_FAN_handler;

	//  RB thread 에서 timeout 에 의해 오는 것이지만 RB 에서 상태요청을 하는 RB_CMD_SENSOR_STATUS 명령을 받았을 때와 동일하게 처리한다.
	rb_cmd_handler_tbl[RB_REPORT_SENSOR_STATUS]		= RB_REPORT_SENSOR_STATUS_handler;

	// RB 에서 내려오는 것들..
	rb_cmd_handler_tbl[RB_CONFIG_UNIX_DATE]			= RB_CONFIG_UNIX_DATE_handler;
	rb_cmd_handler_tbl[RB_CONFIG_UNIX_TIME]			= RB_CONFIG_UNIX_TIME_handler;
	rb_cmd_handler_tbl[RB_CONFIG_SIREN_ON_DURATION]	= RB_CONFIG_SIREN_ON_DURATION_handler;
	rb_cmd_handler_tbl[RB_CONFIG_MOTION_LATENCY]	= RB_CONFIG_MOTION_LATENCY_handler;
	rb_cmd_handler_tbl[RB_CONFIG_OFF_DUTY_TIME]		= RB_CONFIG_OFF_DUTY_TIME_handler;
	rb_cmd_handler_tbl[RB_CONFIG_ON_DUTY_TIME]		= RB_CONFIG_ON_DUTY_TIME_handler;

	return true;
}

bool rb_cmd_handler(rb_msg_t *pq_msg)
{
	if ((SMB_StatusObj.rb_working != true) && (pq_msg->rb_command.type != RB_INFO_RB_WORK_BEGIN)) {
		printf("%s() : SMB_StatusObj.rb_working = false"LINE_TERM, __FUNCTION__);
		return true;
	}
	// Raspberry 가 흔들리면 여기서 실제로 checksum error 가 발생한다. checksum 이 맞을 때만 처리한다.
	if (pq_msg->rb_command.checksum == checksum((uint8_t *)&pq_msg->rb_command, 6)) {
		assert (rb_cmd_handler_tbl[pq_msg->rb_command.type](&pq_msg->rb_command) == true);
	}
	else {
		printf("%s() : checksum() fail.. "LINE_TERM, __FUNCTION__);
	}
	return true;
}
