/**
 ******************************************************************************
 * File Name          : func_manager.c
 * Description        : This file is generated by 위대한 송 인재 on Aug 29, 2025
 ******************************************************************************
 *
 * COPYRIGHT(c) 2024 DSN Co. Ltd.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *   1. Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *   3. Neither the name of STMicroelectronics nor the names of its contributors
 *      may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************
 */

#include "main.h"

extern DMA_HandleTypeDef hdma_usart3_rx;
void func_data_show();

bool ims_sensor_channel_open(void)
{
	assert (HAL_UART_AbortReceive_IT(&huart3) == HAL_OK);
	/* Clean the input path */
	__HAL_UART_FLUSH_DRREGISTER(&huart3);

	assert (HAL_UARTEx_ReceiveToIdle_DMA(&huart3, ims_rx_buffer, IMS_RX_BUF_SIZE) == HAL_OK);
	__HAL_DMA_DISABLE_IT(&hdma_usart3_rx, DMA_IT_HT);
	HAL_NVIC_EnableIRQ(USART3_IRQn);

	return true;
}

static bool ims_packet_integrity_check(manager_msg_t *pmsg)
{
	if (pmsg->head.len != 8) return false;
	if (pmsg->body.Byte[0] != 0xA5) return false;
	if (pmsg->body.Byte[1] != 0xA5) return false;
	if (pmsg->body.Byte[6] != 0x5A) return false;
	if (pmsg->body.Byte[7] != 0x5A) return false;

	return true;
}

static bool manager_msg_handler_ims_data (manager_msg_t *pmsg)
{
	// IMS data 처리.. IMS data 가 깨지지 않은 경우에만 유효 수치로 처리한다.
	if (ims_packet_integrity_check(pmsg) == true) {
//		printf(LINE_TERM);
//		printf("head.len = %d"LINE_TERM, pmsg->head.len);
//		for (uint8_t i = 0 ; i < pmsg->head.len ; i++) {
//			printf("Byte[%d] = %2x ", i, pmsg->body.Byte[i]);
//		}
		//		printf(" luminance = 0x%x, motion = %s, sonic data = 0x%x"LINE_TERM, pmsg->body.Byte[2], (pmsg->body.Byte[3] == 1)?"YES":"NO", pmsg->body.Byte[4]);
		SMB_StatusObj.smb_luminance.luminance = pmsg->body.Byte[2];
		// lamp 의 on/off, 밝기를 제어할 때 아래 밝은지 어두운지를 참고한다. 밝으면 무조건 끄면 된다...
		if (pmsg->body.Byte[2] < SMB_ConfigObj.bright_dark_boundary) SMB_StatusObj.smb_luminance.bright_or_dark = LUMINANCE_BRIGHT;
		else SMB_StatusObj.smb_luminance.bright_or_dark = LUMINANCE_DARK;

		// motion sensor 를 2 개로 바꾸면서 0번 bit, 1번 bit 가 2개의 motion sensor 값. 두개 중에서 1개라도 set 되면 motion 이 감지된 것임..
		if (((motion_t)pmsg->body.Byte[3] & 0x03) != 0) SMB_StatusObj.smb_motion.motion = MOTION_YES;
		else SMB_StatusObj.smb_motion.motion = MOTION_NO;

		// 사무실 천장으로 측정했을 때 180cm 의 값이 0x0790... 이걸 기준으로 차후 거리값에 따른 default  값을 산정한다..
		SMB_StatusObj.smb_motion.sonic_raw_data = ((pmsg->body.Byte[4] << 8) | pmsg->body.Byte[5]);
		// 초음파 센서값이 기준값보다 작은 경우에 사람이 있는 것으로 간주하고 motion 감지했을 때와 동일한 동작을 수행한다. (초음파센서에 무언가 걸려 있으면 항상 사람이 있다고 될텐데... ???)
		if (SMB_StatusObj.smb_motion.sonic_raw_data < SMB_StatusObj.smb_motion.sonic_threshold)	SMB_StatusObj.smb_motion.sonic_motion = SONIC_MOTION_YES;
		else SMB_StatusObj.smb_motion.sonic_motion = SONIC_MOTION_NO;

		// 여기서 위의 3가지 data 를 update 하는 일만 하고 여기에 따른 lamp 의 조작은 manager_msg_handler_peri_oper() 에 맡긴다.
	}
	else {
		// 수신 packet 이 error 가 나더라도 500ms 후에 다음 packet 이 올것이므로 수신 error 만 count 하고 버린다.
		SMB_StatusObj.ims_packet_error_counter++;
	}
	return true;
}

static bool manager_msg_handler_default(manager_msg_t *pmsg)
{
	char manager_msg[100];

	switch (pmsg->head.type) {
	case MANAGER_MSG_ADC_READ :		strcpy (manager_msg, "MANAGER_MSG_ADC_READ"); break;
	case MANAGER_MSG_IMS :			strcpy (manager_msg, "MANAGER_MSG_IMS"); break;
	case MANAGER_MSG_DATA_SHOW :	strcpy (manager_msg, "MANAGER_MSG_DATA_SHOW"); break;
	case MANAGER_MSG_PERI_OPER :	strcpy (manager_msg, "MANAGER_MSG_PERI_OPER"); break;
	case MANAGER_MSG_EMER_BTN :		strcpy (manager_msg, "MANAGER_MSG_EMER_BTN"); break;
	case MANAGER_MSG_FIRE_DOOR :	strcpy (manager_msg, "MANAGER_MSG_FIRE_DOOR"); break;
	case MANAGER_MSG_AED_DOOR :		strcpy (manager_msg, "MANAGER_MSG_AED_DOOR"); break;
	case MANAGER_MSG_FLOODING :		strcpy (manager_msg, "MANAGER_MSG_FLOODING"); break;
	default :						strcpy (manager_msg, "UNKNOWN type"); break;
	}

	printf("%s() : manager_msg = %s"LINE_TERM, __FUNCTION__, manager_msg);

	return true;
}

static bool manager_msg_handler_adc_read (manager_msg_t *pmsg)
{
	//	printf("%s()"LINE_TERM, __FUNCTION__);
	assert (HAL_ADC_Start_DMA(&hadc1, (uint32_t *)aADCxConvertedData, ADC_CONVERTED_DATA_BUFFER_SIZE) == HAL_OK);

	return true;
}

bool data_show_begin (void)
{
	assert (osTimerList[TMR_IDX_SMB_DATA_SHOW].osTimerId != NULL);
	assert (osTimerStart(osTimerList[TMR_IDX_SMB_DATA_SHOW].osTimerId, osTimerList[TMR_IDX_SMB_DATA_SHOW].timeout_tick) == osOK);
	return true;
}

static bool manager_msg_handler_data_show (manager_msg_t *pmsg)
{
	(SMB_StatusObj.smb_data_show_flag == true)?func_data_show():(void)0;

	return true;
}

bool IsThisEmergency()
{
	bool res;

	if (SMB_StatusObj.EMERGENCY.emer_by_button == true) res = true;
	else if (SMB_StatusObj.EMERGENCY.emer_by_fire_door == true) res = true;
	else if (SMB_StatusObj.EMERGENCY.emer_by_aed_door == true) res = true;
	else if (SMB_StatusObj.EMERGENCY.emer_by_flood == true) res = true;
	else res = false;

	return res;
}

static bool manager_msg_handler_emer_btn (manager_msg_t *pmsg)
{
	SMB_StatusObj.emer_btn_status = get_emer_btn_status;
	if (SMB_StatusObj.emer_btn_status == EMER_BTN_PRESSED) {
		SMB_StatusObj.EMERGENCY.emer_by_button = true;
		sb_report_to_rb(RB_REPORT_EMER_BTN_PRESS, 0);
		assert (osTimerList[TMR_IDX_EMER_BTN].osTimerId != NULL);
		assert (osTimerStart(osTimerList[TMR_IDX_EMER_BTN].osTimerId, osTimerList[TMR_IDX_EMER_BTN].timeout_tick) == osOK);
	}
	else {
		sb_report_to_rb(RB_REPORT_EMER_BTN_RELEASE, 0);
	}

	return true;
}

static bool manager_msg_handler_fire_door (manager_msg_t *pmsg)
{
	SMB_StatusObj.fire_door_status = get_fire_door_status;
	if (SMB_StatusObj.fire_door_status == FIRE_DOOR_OPEN) {
		SMB_StatusObj.EMERGENCY.emer_by_fire_door = true;
		sb_report_to_rb(RB_REPORT_FIRE_DOOR_OPEN, 0);
		assert (osTimerList[TMR_IDX_EMER_FIRE_DOOR].osTimerId != NULL);
		assert (osTimerStart(osTimerList[TMR_IDX_EMER_FIRE_DOOR].osTimerId, osTimerList[TMR_IDX_EMER_FIRE_DOOR].timeout_tick) == osOK);
	}
	else {
		sb_report_to_rb(RB_REPORT_FIRE_DOOR_CLOSED, 0);

	}

	return true;
}

static bool manager_msg_handler_aed_door (manager_msg_t *pmsg)
{
	SMB_StatusObj.aed_door_status = get_aed_door_status;
	if (SMB_StatusObj.aed_door_status == AED_DOOR_OPEN) {
		SMB_StatusObj.EMERGENCY.emer_by_aed_door = true;
		sb_report_to_rb(RB_REPORT_AED_DOOR_OPEN, 0);
		assert (osTimerList[TMR_IDX_EMER_AED_DOOR].osTimerId != NULL);
		assert (osTimerStart(osTimerList[TMR_IDX_EMER_AED_DOOR].osTimerId, osTimerList[TMR_IDX_EMER_AED_DOOR].timeout_tick) == osOK);
	}
	else {
		sb_report_to_rb(RB_REPORT_AED_DOOR_CLOSED, 0);

	}

	return true;
}

static bool manager_msg_handler_flooding (manager_msg_t *pmsg)
{
	SMB_StatusObj.flood_status = get_flood_status;
	if (SMB_StatusObj.flood_status == FLOOD_HAPPEN) {
		SMB_StatusObj.EMERGENCY.emer_by_flood = true;
		sb_report_to_rb(RB_REPORT_FLOOD_HAPPEN, 0);
	}
	else {
		sb_report_to_rb(RB_REPORT_FLOOD_CLEAR, 0);

	}

	return true;
}

static lamp_level_t get_lamp_level_by_luminance(uint8_t luminance)
{
	if (luminance > 0xF0) return LAMP_LEVEL_MAX;
	else if (luminance > 0xE0) return LAMP_LEVEL_8;
	else if (luminance > 0xD0) return LAMP_LEVEL_7;
	else if (luminance > 0xC0) return LAMP_LEVEL_6;
	else if (luminance > 0xB0) return LAMP_LEVEL_5;
	else if (luminance > 0xA0) return LAMP_LEVEL_4;
	else if (luminance > 0x90) return LAMP_LEVEL_3;
	else if (luminance > 0x80) return LAMP_LEVEL_2;
	else if (luminance > 0x70) return LAMP_LEVEL_1;
	else return LAMP_LEVEL_0;
}

static bool manager_msg_handler_peri_oper (manager_msg_t *pmsg)
{
	if (IsThisEmergency() == true) {
		// 비상 버튼의 경우 siren 은 통화를 위해 꺼야 하고 lamp 는 최대한의 밝기를 유지해야 하며, LEDBAR 도 최대한의 밝기로 켜두기로 한다.
		if (SMB_StatusObj.EMERGENCY.emer_by_button == true) {
//			SMB_ControlObj.sirenObj.siren_set(SIREN_ON);
			SMB_ControlObj.lampObj.lamp_set(LAMP_LEVEL_MAX);
			SMB_ControlObj.ledbarObj.ledbar_color_set(LEDBAR_WHITE);
			SMB_ControlObj.speakerObj.speaker_set(SPEAKER_ON);
		}

		// 소화기 문 열림의 경우 siren 은 최대 volume 으로 켜고 lamp 는 최대한의 밝기를 유지해야 하며, LEDBAR 도 최대한의 밝기로 켜두기로 한다.
		if (SMB_StatusObj.EMERGENCY.emer_by_fire_door == true) {
			SMB_ControlObj.sirenObj.siren_set(SIREN_ON);
			SMB_ControlObj.lampObj.lamp_set(LAMP_LEVEL_MAX);
			SMB_ControlObj.ledbarObj.ledbar_color_set(LEDBAR_WHITE);
		}

		// AED 문 열림의 경우 siren 은 최대 volume 으로 켜고 lamp 는 최대한의 밝기를 유지해야 하며, LEDBAR 도 최대한의 밝기로 켜두기로 한다.
		if (SMB_StatusObj.EMERGENCY.emer_by_aed_door == true) {
			SMB_ControlObj.sirenObj.siren_set(SIREN_ON);
			SMB_ControlObj.lampObj.lamp_set(LAMP_LEVEL_MAX);
			SMB_ControlObj.ledbarObj.ledbar_color_set(LEDBAR_WHITE);
		}

		if (SMB_StatusObj.EMERGENCY.emer_by_flood == true) {

		}
		return true;		// 비상상황이면 비상 상황에 대한 처리를 하고 이후 처리하지 않고 return 한다.
	}

	if (SMB_StatusObj.console_mani_flag == true) return true;
	if (SMB_StatusObj.rb_mani_flag == true) return true;

	// FAN, PTC
	if (SMB_adc_value.AEDT > SMB_ConfigObj.aedt_high_mark) {
		SMB_ControlObj.fanObj.fan_set(FAN_ON);
		SMB_ControlObj.ptcObj.ptc_set(PTC_OFF);
	}
	else if (SMB_adc_value.AEDT > SMB_ConfigObj.aedt_mid_mark) {
		SMB_ControlObj.ptcObj.ptc_set(PTC_OFF);
	}
	else if (SMB_adc_value.AEDT > SMB_ConfigObj.aedt_low_mark) {
		SMB_ControlObj.fanObj.fan_set(FAN_OFF);
	}
	else {
		SMB_ControlObj.fanObj.fan_set(FAN_OFF);
		SMB_ControlObj.ptcObj.ptc_set(PTC_ON);
	}

	// LAMP
	SMB_ControlObj.lampObj.lamp_set(get_lamp_level_by_luminance(SMB_StatusObj.smb_luminance.luminance));

	// LEDBAR

	// SPEAKER : 제어하지 않는다.
	// LCD : 제어하지 않는다.
	// INVERTER : 제어하지 않는다.
	// MUCHAR1 : 제어하지 않는다.
	// MUCHAR2 : 제어하지 않는다.
	// YUCHAR : 제어하지 않는다.
	// SIREN : 제어하지 않는다.
	// LTE : 제어하지 않는다.

	return true;
}

bool manager_msg_handler_tbl_init(void)
{
	for (uint32_t i = 0 ; i < MANAGER_MSG_END ; i++) {
		manager_msg_handler_tbl[i] = manager_msg_handler_default;
	}

	manager_msg_handler_tbl[MANAGER_MSG_ADC_READ]		= manager_msg_handler_adc_read;
	manager_msg_handler_tbl[MANAGER_MSG_IMS]			= manager_msg_handler_ims_data;
	manager_msg_handler_tbl[MANAGER_MSG_DATA_SHOW]		= manager_msg_handler_data_show;
	manager_msg_handler_tbl[MANAGER_MSG_PERI_OPER]		= manager_msg_handler_peri_oper;
	manager_msg_handler_tbl[MANAGER_MSG_EMER_BTN]		= manager_msg_handler_emer_btn;
	manager_msg_handler_tbl[MANAGER_MSG_FIRE_DOOR]		= manager_msg_handler_fire_door;
	manager_msg_handler_tbl[MANAGER_MSG_AED_DOOR]		= manager_msg_handler_aed_door;
	manager_msg_handler_tbl[MANAGER_MSG_FLOODING]		= manager_msg_handler_flooding;

	return true;
}


