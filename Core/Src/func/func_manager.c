/**
 ******************************************************************************
 * File Name          : func_manager.c
 * Description        : This file is generated by 위대한 송 인재 on Aug 29, 2025
 ******************************************************************************
 *
 * COPYRIGHT(c) 2024 DSN Co. Ltd.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *   1. Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *   3. Neither the name of STMicroelectronics nor the names of its contributors
 *      may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************
 */

#include "main.h"

extern DMA_HandleTypeDef hdma_usart3_rx;
void func_data_show();

bool ims_sensor_channel_open(void)
{
	assert (HAL_UART_AbortReceive_IT(&huart3) == HAL_OK);
	/* Clean the input path */
	__HAL_UART_FLUSH_DRREGISTER(&huart3);

	assert (HAL_UARTEx_ReceiveToIdle_DMA(&huart3, ims_rx_buffer, IMS_RX_BUF_SIZE) == HAL_OK);
	__HAL_DMA_DISABLE_IT(&hdma_usart3_rx, DMA_IT_HT);
	HAL_NVIC_EnableIRQ(USART3_IRQn);

	return true;
}

static bool ims_packet_integrity_check(manager_msg_t *pmsg)
{
	if (pmsg->head.len != 8) return false;
	if (pmsg->body.Byte[0] != 0xA5) return false;
	if (pmsg->body.Byte[1] != 0xA5) return false;
	if (pmsg->body.Byte[6] != 0x5A) return false;
	if (pmsg->body.Byte[7] != 0x5A) return false;

	return true;
}

static bool manager_msg_handler_ims_data (manager_msg_t *pmsg)
{
	// IMS data 처리.. IMS data 가 깨지지 않은 경우에만 유효 수치로 처리한다.
	if (ims_packet_integrity_check(pmsg) == true) {
		//		printf(LINE_TERM);
		//		printf("head.len = %d"LINE_TERM, pmsg->head.len);
		//		for (uint8_t i = 0 ; i < pmsg->head.len ; i++) {
		//			printf("Byte[%d] = %2x ", i, pmsg->body.Byte[i]);
		//		}
		//		printf(" luminance = 0x%x, motion = %s, sonic data = 0x%x"LINE_TERM, pmsg->body.Byte[2], (pmsg->body.Byte[3] == 1)?"YES":"NO", pmsg->body.Byte[4]);
		SMB_StatusObj.smb_luminance.luminance = pmsg->body.Byte[2];
		// lamp 의 on/off, 밝기를 제어할 때 아래 밝은지 어두운지를 참고한다. 밝으면 무조건 끄면 된다...
		if (pmsg->body.Byte[2] < SMB_ConfigObj.bright_dark_boundary) SMB_StatusObj.smb_luminance.bright_or_dark = LUMINANCE_BRIGHT;
		else SMB_StatusObj.smb_luminance.bright_or_dark = LUMINANCE_DARK;

		// motion sensor 를 2 개로 바꾸면서 0번 bit, 1번 bit 가 2개의 motion sensor 값. 두개 중에서 1개라도 set 되면 motion 이 감지된 것임..
		if (((motion_t)pmsg->body.Byte[3] & 0x02) != 0) {
			assert (osTimerList[TMR_IDX_MOTION_LATENCY].osTimerId != NULL);
			assert (osTimerStart(osTimerList[TMR_IDX_MOTION_LATENCY].osTimerId, osTimerList[TMR_IDX_MOTION_LATENCY].timeout_tick) == osOK);
			SMB_StatusObj.smb_motion.motion = MOTION_YES;
		}
	}
	else {
		// 수신 packet 이 error 가 나더라도 500ms 후에 다음 packet 이 올것이므로 수신 error 만 count 하고 버린다.
		SMB_StatusObj.ims_packet_error_counter++;
	}
	return true;
}

static bool manager_msg_handler_default(manager_msg_t *pmsg)
{
	char manager_msg[100];

	switch (pmsg->head.type) {
	case MANAGER_MSG_ADC_READ :		strcpy (manager_msg, "MANAGER_MSG_ADC_READ"); break;
	case MANAGER_MSG_IMS :			strcpy (manager_msg, "MANAGER_MSG_IMS"); break;
	case MANAGER_MSG_DATA_SHOW :	strcpy (manager_msg, "MANAGER_MSG_DATA_SHOW"); break;
	case MANAGER_MSG_PERI_OPER :	strcpy (manager_msg, "MANAGER_MSG_PERI_OPER"); break;
	case MANAGER_MSG_EMER_BTN :		strcpy (manager_msg, "MANAGER_MSG_EMER_BTN"); break;
	case MANAGER_MSG_FIRE_DOOR :	strcpy (manager_msg, "MANAGER_MSG_FIRE_DOOR"); break;
	case MANAGER_MSG_AED_DOOR :		strcpy (manager_msg, "MANAGER_MSG_AED_DOOR"); break;
	case MANAGER_MSG_FLOODING :		strcpy (manager_msg, "MANAGER_MSG_FLOODING"); break;
	default :						strcpy (manager_msg, "UNKNOWN type"); break;
	}

	printf("%s() : manager_msg = %s"LINE_TERM, __FUNCTION__, manager_msg);

	return true;
}

static bool manager_msg_handler_adc_read (manager_msg_t *pmsg)
{
	//	printf("%s()"LINE_TERM, __FUNCTION__);
	assert (HAL_ADC_Start_DMA(&hadc1, (uint32_t *)aADCxConvertedData, ADC_CONVERTED_DATA_BUFFER_SIZE) == HAL_OK);

	/*******************************************************************************
	 fake AEDT
	 *******************************************************************************/
	if (SMB_StatusObj.fake_AEDT.IsFaking == FAKE_AEDT_YES) {
		if (SMB_StatusObj.fake_AEDT.fake_dir == FAKE_DIR_UP) SMB_StatusObj.fake_AEDT.fake_temp++;
		else SMB_StatusObj.fake_AEDT.fake_temp--;
		if ((SMB_StatusObj.fake_AEDT.fake_temp > 40) || (SMB_StatusObj.fake_AEDT.fake_temp < -10)) SMB_StatusObj.fake_AEDT.fake_dir = !SMB_StatusObj.fake_AEDT.fake_dir;
	}

	return true;
}

bool data_show_begin (void)
{
	assert (osTimerList[TMR_IDX_SMB_DATA_SHOW].osTimerId != NULL);
	assert (osTimerStart(osTimerList[TMR_IDX_SMB_DATA_SHOW].osTimerId, osTimerList[TMR_IDX_SMB_DATA_SHOW].timeout_tick) == osOK);
	return true;
}

static bool manager_msg_handler_data_show (manager_msg_t *pmsg)
{
	(SMB_StatusObj.smb_data_show_flag == true)?func_data_show():(void)0;

	return true;
}

bool IsThisEmergency()
{
	bool res;

	if (SMB_StatusObj.EMERGENCY.emer_by_button == true) res = true;
	else if (SMB_StatusObj.EMERGENCY.emer_by_fire_door == true) res = true;
	else if (SMB_StatusObj.EMERGENCY.emer_by_aed_door == true) res = true;
	else if (SMB_StatusObj.EMERGENCY.emer_by_flood == true) res = true;
	else res = false;

	return res;
}

bool save_peri_status()
{
	SMB_Control_BackupObj.ledbar_color 			= SMB_ControlObj.ledbarObj.ledbar_color;
	SMB_Control_BackupObj.siren_flag 			= SMB_ControlObj.sirenObj.siren_flag;
	SMB_Control_BackupObj.lamp_level 			= SMB_ControlObj.lampObj.lamp_level;

	return true;
}

bool restore_peri_status()
{
	SMB_ControlObj.ledbarObj.ledbar_color 		= SMB_Control_BackupObj.ledbar_color;
	SMB_ControlObj.sirenObj.siren_flag 			= SMB_Control_BackupObj.siren_flag;
	SMB_ControlObj.lampObj.lamp_level 			= SMB_Control_BackupObj.lamp_level;

	return true;
}

/* 비상 상황에 대한 처리 방안에 대한 최종 결론을 내리고 수정한다.
 1. 비상 버튼 : 타임아웃이 될 때까지 비상 상황 유지..
 2. fire door :  door 가 열린 상태면 비상 상황 지속, door 가 닫히면 비상 상황 종료로 구현한다. 고로 timeout 은 필요없다.
 3. AED door :  door 가 열린 상태면 비상 상황 지속, door 가 닫히면 비상 상황 종료로 구현한다. 고로 timeout 은 필요없다.
 4. 침수 : 관리자가 와서 침수 처리를 한 후 system 을 reset 시켜야만 비상 상황 종료로 구현한다.
 */
static bool manager_msg_handler_emer_btn (manager_msg_t *pmsg)
{
	SMB_StatusObj.emer_btn_status = get_emer_btn_status;
	if (SMB_StatusObj.emer_btn_status == EMER_BTN_PRESSED) {
		if (IsThisEmergency() == false) assert (save_peri_status() == true);		// 현재 진행 중인 비상 상황이 없을 때 peri 상태를 저장해 둔다.
		SMB_StatusObj.EMERGENCY.emer_by_button = true;
		sb_report_to_rb(RB_REPORT_EMER_BTN_PRESS, 0);
		assert (osTimerList[TMR_IDX_EMER_BTN].osTimerId != NULL);
		assert (osTimerStart(osTimerList[TMR_IDX_EMER_BTN].osTimerId, osTimerList[TMR_IDX_EMER_BTN].timeout_tick) == osOK);
	}
	else {
		sb_report_to_rb(RB_REPORT_EMER_BTN_RELEASE, 0);
	}

	return true;
}

static bool manager_msg_handler_fire_door (manager_msg_t *pmsg)
{
	SMB_StatusObj.fire_door_status = get_fire_door_status;
	if (SMB_StatusObj.fire_door_status == FIRE_DOOR_OPEN) {
		if (IsThisEmergency() == false) assert (save_peri_status() == true);		// 현재 진행 중인 비상 상황이 없을 때 peri 상태를 저장해 둔다.
		SMB_StatusObj.EMERGENCY.emer_by_fire_door = true;
		sb_report_to_rb(RB_REPORT_FIRE_DOOR_OPEN, 0);
	}
	else {
		SMB_StatusObj.EMERGENCY.emer_by_fire_door = false;
		if (IsThisEmergency() == false) assert (restore_peri_status() == true);		// 현재 진행 중인 비상 상황이 없을 때 peri 상태를 저장해 둔다.
		sb_report_to_rb(RB_REPORT_FIRE_DOOR_CLOSED, 0);
	}

	return true;
}

static bool manager_msg_handler_aed_door (manager_msg_t *pmsg)
{
	SMB_StatusObj.aed_door_status = get_aed_door_status;
	if (SMB_StatusObj.aed_door_status == AED_DOOR_OPEN) {
		if (IsThisEmergency() == false) assert (save_peri_status() == true);		// 현재 진행 중인 비상 상황이 없을 때 peri 상태를 저장해 둔다.
		SMB_StatusObj.EMERGENCY.emer_by_aed_door = true;
		sb_report_to_rb(RB_REPORT_AED_DOOR_OPEN, 0);
	}
	else {
		SMB_StatusObj.EMERGENCY.emer_by_aed_door = false;
		if (IsThisEmergency() == false) assert (restore_peri_status() == true);		// 현재 진행 중인 비상 상황이 없을 때 peri 상태를 저장해 둔다.
		sb_report_to_rb(RB_REPORT_AED_DOOR_CLOSED, 0);
	}

	return true;
}

// 침수 발생은 Fire door 나 AED door 와 달리 처리해야 한다. 담당하는 사람이 와서 침수를 해결하고 시스템을 reset 할 때까지 계속 비상상황이 유지되도록 한다.
static bool manager_msg_handler_flooding (manager_msg_t *pmsg)
{
	SMB_StatusObj.flood_status = get_flood_status;
	if (SMB_StatusObj.flood_status == FLOOD_HAPPEN) {
		if (IsThisEmergency() == false) assert (save_peri_status() == true);		// 현재 진행 중인 비상 상황이 없을 때 peri 상태를 저장해 둔다.
		SMB_StatusObj.EMERGENCY.emer_by_flood = true;
		sb_report_to_rb(RB_REPORT_FLOOD_HAPPEN, 0);
	}
	else {
		//		SMB_StatusObj.EMERGENCY.emer_by_flood = false;
		//		if (IsThisEmergency() == false) assert (restore_peri_status() == true);
		sb_report_to_rb(RB_REPORT_FLOOD_CLEAR, 0);
	}

	return true;
}

static lamp_level_t get_lamp_level_by_luminance(uint8_t luminance)
{
	if (luminance > 0xF0) return LAMP_LEVEL_MAX;
	else if (luminance > 0xF0) return LAMP_LEVEL_9;
	else if (luminance > 0xE0) return LAMP_LEVEL_8;
	else if (luminance > 0xD0) return LAMP_LEVEL_7;
	else if (luminance > 0xC0) return LAMP_LEVEL_6;
	else if (luminance > 0xB0) return LAMP_LEVEL_5;
	else if (luminance > 0xA0) return LAMP_LEVEL_4;
	else if (luminance > 0x90) return LAMP_LEVEL_3;
	else if (luminance > 0x80) return LAMP_LEVEL_2;
	else if (luminance > 0x70) return LAMP_LEVEL_1;
	else return LAMP_LEVEL_0;
}

static bool peripheral_operation_in_emergency(void)
{
	assert (IsThisEmergency() == true);

	// 비상 버튼의 경우 siren 은 통화를 위해 꺼야 하고 lamp 는 최대한의 밝기를 유지해야 하며, LEDBAR 도 최대한의 밝기로 켜두기로 한다.
	// 윤 소장님이 siren 을 켜야 한다고 해서 일단 siren 을 켜는 것으로...
	if (SMB_StatusObj.EMERGENCY.emer_by_button == true) {
		SMB_ControlObj.sirenObj.siren_set(SIREN_ON);
		SMB_ControlObj.lampObj.lamp_set(LAMP_LEVEL_MAX);
		SMB_ControlObj.ledbarObj.ledbar_color_set(LEDBAR_WHITE);
		SMB_ControlObj.speakerObj.speaker_set(SPEAKER_ON);
	}

	// 소화기 문 열림의 경우 siren 은 켜고 lamp 는 최대한의 밝기를 유지해야 하며, LEDBAR 도 최대한의 밝기로 켜두기로 한다.
	if (SMB_StatusObj.EMERGENCY.emer_by_fire_door == true) {
		SMB_ControlObj.sirenObj.siren_set(SIREN_ON);
		SMB_ControlObj.lampObj.lamp_set(LAMP_LEVEL_MAX);
		SMB_ControlObj.ledbarObj.ledbar_color_set(LEDBAR_WHITE);
	}

	// 소화기 문 열림의 경우 siren 은 켜고 lamp 는 최대한의 밝기를 유지해야 하며, LEDBAR 도 최대한의 밝기로 켜두기로 한다.
	if (SMB_StatusObj.EMERGENCY.emer_by_aed_door == true) {
		SMB_ControlObj.sirenObj.siren_set(SIREN_ON);
		SMB_ControlObj.lampObj.lamp_set(LAMP_LEVEL_MAX);
		SMB_ControlObj.ledbarObj.ledbar_color_set(LEDBAR_WHITE);
	}

	// 침수 발생의 경우 siren 은 켜고 lamp 는 최대한의 밝기를 유지해야 하며, LEDBAR 도 최대한의 밝기로 켜두기로 한다.
	if (SMB_StatusObj.EMERGENCY.emer_by_flood == true) {
		SMB_ControlObj.sirenObj.siren_set(SIREN_ON);
		SMB_ControlObj.lampObj.lamp_set(LAMP_LEVEL_MAX);
		SMB_ControlObj.ledbarObj.ledbar_color_set(LEDBAR_WHITE);
	}

	return true;
}

static bool fan_ptc_control_by_aedt()
{
	if (SMB_adc_value.AEDT > SMB_ConfigObj.aedt_high_mark) {
		SMB_ControlObj.fanObj.fan_set(FAN_ON);
		SMB_ControlObj.ptcObj.ptc_set(PTC_OFF);
	}
	else if (SMB_adc_value.AEDT > SMB_ConfigObj.aedt_normal_high) {
		SMB_ControlObj.ptcObj.ptc_set(PTC_OFF);
	}
	else if (SMB_adc_value.AEDT > SMB_ConfigObj.aedt_normal_low) {
		SMB_ControlObj.fanObj.fan_set(FAN_OFF);
		SMB_ControlObj.ptcObj.ptc_set(PTC_OFF);
	}
	else if (SMB_adc_value.AEDT > SMB_ConfigObj.aedt_low_mark) {
		SMB_ControlObj.fanObj.fan_set(FAN_OFF);
	}
	else {
		SMB_ControlObj.fanObj.fan_set(FAN_OFF);
		SMB_ControlObj.ptcObj.ptc_set(PTC_ON);
	}

	// PTC 와 FAN 이 둘 다 ON 되는 경우를 찾기 위함..
	if (SMB_ControlObj.fanObj.fan_flag == FAN_ON) assert (SMB_ControlObj.ptcObj.ptc_flag == PTC_OFF);
	if (SMB_ControlObj.ptcObj.ptc_flag == PTC_ON) assert (SMB_ControlObj.fanObj.fan_flag == FAN_OFF);

	return true;
}

static bool lamp_control_by_presence()
{
	if (SMB_StatusObj.smb_motion.motion == MOTION_YES) {
		SMB_ControlObj.lampObj.lamp_set(get_lamp_level_by_luminance(SMB_StatusObj.smb_luminance.luminance));
	}
	else {
		SMB_ControlObj.lampObj.lamp_set(LAMP_LEVEL_0);
	}

	return true;
}

static bool manager_msg_handler_peri_oper (manager_msg_t *pmsg)
{
	if (SMB_StatusObj.manual_mode == true) return true;	// 현재 console 에 의한 제어가 진행되고 있으면 operation 을 생략하고 return.

	// 비상 상황이면 비상상황에 맞는 처리만 하고 일상적인 처리는 하지 않는다.
	if (IsThisEmergency() == true) {
		assert (peripheral_operation_in_emergency() == true);
		return true;
	}

	// FAN, PTC
	assert (fan_ptc_control_by_aedt() == true);
	assert (lamp_control_by_presence() == true);

	// LEDBAR
	SMB_ControlObj.ledbarObj.ledbar_color_set(SMB_ControlObj.ledbarObj.ledbar_color);

	// SPEAKER
	SMB_ControlObj.speakerObj.speaker_set(SMB_ControlObj.speakerObj.speaker_flag);

	// LCD
	SMB_ControlObj.lcdObj.lcd_set(SMB_ControlObj.lcdObj.lcd_flag);

	// INVERTER
	SMB_ControlObj.inverterObj.inverter_set(SMB_ControlObj.inverterObj.inverter_flag);

	// YUCHAR
	SMB_ControlObj.yucharObj.yuchar_set(SMB_ControlObj.yucharObj.yuchar_flag);

	// MUCHAR1
	SMB_ControlObj.muchar1Obj.muchar1_set(SMB_ControlObj.muchar1Obj.muchar1_flag);

	// MUCHAR2
	SMB_ControlObj.muchar2Obj.muchar2_set(SMB_ControlObj.muchar2Obj.muchar2_flag);

	// LTE
	SMB_ControlObj.lteObj.lte_set(SMB_ControlObj.lteObj.lte_flag);

	// SIREN
	SMB_ControlObj.sirenObj.siren_set(SMB_ControlObj.sirenObj.siren_flag);

	return true;
}

bool manager_msg_handler_tbl_init(void)
{
	for (uint32_t i = 0 ; i < MANAGER_MSG_END ; i++) {
		manager_msg_handler_tbl[i] = manager_msg_handler_default;
	}

	manager_msg_handler_tbl[MANAGER_MSG_ADC_READ]		= manager_msg_handler_adc_read;
	manager_msg_handler_tbl[MANAGER_MSG_IMS]			= manager_msg_handler_ims_data;
	manager_msg_handler_tbl[MANAGER_MSG_DATA_SHOW]		= manager_msg_handler_data_show;
	manager_msg_handler_tbl[MANAGER_MSG_PERI_OPER]		= manager_msg_handler_peri_oper;
	manager_msg_handler_tbl[MANAGER_MSG_EMER_BTN]		= manager_msg_handler_emer_btn;
	manager_msg_handler_tbl[MANAGER_MSG_FIRE_DOOR]		= manager_msg_handler_fire_door;
	manager_msg_handler_tbl[MANAGER_MSG_AED_DOOR]		= manager_msg_handler_aed_door;
	manager_msg_handler_tbl[MANAGER_MSG_FLOODING]		= manager_msg_handler_flooding;

	return true;
}


