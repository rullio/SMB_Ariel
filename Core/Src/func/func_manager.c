/**
 ******************************************************************************
 * File Name          : func_manager.c
 * Description        : This file is generated by 위대한 송 인재 on Aug 29, 2025
 ******************************************************************************
 *
 * COPYRIGHT(c) 2024 DSN Co. Ltd.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *   1. Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *   3. Neither the name of STMicroelectronics nor the names of its contributors
 *      may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************
 */

#include "main.h"

extern DMA_HandleTypeDef hdma_usart3_rx;
void func_data_show();

bool ims_sensor_channel_open(void)
{
	assert (HAL_UART_AbortReceive_IT(&huart3) == HAL_OK);
	/* Clean the input path */
	__HAL_UART_FLUSH_DRREGISTER(&huart3);

	assert (HAL_UARTEx_ReceiveToIdle_DMA(&huart3, ims_rx_buffer, IMS_RX_BUF_SIZE) == HAL_OK);
	__HAL_DMA_DISABLE_IT(&hdma_usart3_rx, DMA_IT_HT);
	HAL_NVIC_EnableIRQ(USART3_IRQn);

	return true;
}

static bool ims_packet_integrity_check(manager_msg_t *pmsg)
{
	if (pmsg->head.len != 8) return false;
	if (pmsg->body.Byte[0] != 0xA5) return false;
	if (pmsg->body.Byte[1] != 0xA5) return false;
	if (pmsg->body.Byte[6] != 0x5A) return false;
	if (pmsg->body.Byte[7] != 0x5A) return false;

	return true;
}

static bool manager_msg_handler_ims_data (manager_msg_t *pmsg)
{
	// IMS data 처리.. IMS data 가 깨지지 않은 경우에만 유효 수치로 처리한다.
	if (ims_packet_integrity_check(pmsg) == true) {
		printf("%s : luminance = 0x%x, motion = %s, sonic data = 0x%x", __FUNCTION__, pmsg->body.Byte[2], (pmsg->body.Byte[3] == 1)?"YES":"NO", pmsg->body.Byte[4]);
		SMB_StatusObj.smb_luminance.luminance = pmsg->body.Byte[2];
		// lamp 의 on/off, 밝기를 제어할 때 아래 밝은지 어두운지를 참고한다. 밝으면 무조건 끄면 된다...
		if (pmsg->body.Byte[2] < SMB_ConfigObj.luminance_threshold) SMB_StatusObj.smb_luminance.bright_or_dark = LUMINANCE_BRIGHT;
		else SMB_StatusObj.smb_luminance.bright_or_dark = LUMINANCE_DARK;

		if ((motion_t)pmsg->body.Byte[3] == MOTION_YES) SMB_StatusObj.smb_motion.motion = MOTION_YES;
		else SMB_StatusObj.smb_motion.motion = MOTION_NO;

		SMB_StatusObj.smb_motion.sonic_raw_data = ((pmsg->body.Byte[4] << 8) | pmsg->body.Byte[5]);;
		// 초음파 센서값이 기준값보다 작은 경우에 사람이 있는 것으로 간주하고 motion 감지했을 때와 동일한 동작을 수행한다. (초음파센서에 무언가 걸려 있으면 항상 사람이 있다고 될텐데... ???)
		if (SMB_StatusObj.smb_motion.sonic_raw_data < SMB_StatusObj.smb_motion.sonic_threshold)	SMB_StatusObj.smb_motion.sonic_motion = SONIC_MOTION_YES;
		else SMB_StatusObj.smb_motion.sonic_motion = SONIC_MOTION_NO;

		// 여기서 위의 3가지 data 를 가지고 다음 동작을 결정한다.. 센서 보드 연결한 후에 결정하자.. 지금은 음성에 가 있음..
	}
	else {
		// 수신 packet 이 error 가 나더라도 500ms 후에 다음 packet 이 올것이므로 수신 error 만 count 하고 버린다.
		SMB_StatusObj.ims_packet_error_counter++;
	}
	return true;
}

static bool manager_msg_handler_default(manager_msg_t *pmsg)
{
	char manager_msg[100];

	switch (pmsg->head.type) {
	case MANAGER_MSG_ADC_READ : strcpy (manager_msg, "MANAGER_MSG_ADC_READ"); break;
	default : strcpy (manager_msg, "UNKNOWN type"); break;
	}

	printf("%s() : manager_msg = %s"LINE_TERM, __FUNCTION__, manager_msg);

	return true;
}

static bool manager_msg_handler_adc_read (manager_msg_t *pmsg)
{
	//	printf("%s()"LINE_TERM, __FUNCTION__);
	assert (HAL_ADC_Start_DMA(&hadc1, (uint32_t *)aADCxConvertedData, ADC_CONVERTED_DATA_BUFFER_SIZE) == HAL_OK);

	return true;
}

bool data_show_begin (void)
{
	assert (osTimerList[TMR_IDX_SMB_DATA_SHOW].osTimerId != NULL);
	assert (osTimerStart(osTimerList[TMR_IDX_SMB_DATA_SHOW].osTimerId, SMB_DATA_SHOW_TIMEOUT) == osOK);
	return true;
}

static bool manager_msg_handler_data_show (manager_msg_t *pmsg)
{
	(SMB_StatusObj.smb_data_show_flag == true)?func_data_show():(void)0;

	return true;
}

static bool manager_msg_handler_emer_btn (manager_msg_t *pmsg)
{
	printf("%s()"LINE_TERM, __FUNCTION__);
	led_com_toggle;

	return true;
}

static bool manager_msg_handler_fire_door (manager_msg_t *pmsg)
{
	printf("%s()"LINE_TERM, __FUNCTION__);
	led_com_toggle;

	return true;
}

static bool manager_msg_handler_aed_door (manager_msg_t *pmsg)
{
	printf("%s()"LINE_TERM, __FUNCTION__);
	led_com_toggle;

	return true;
}

static bool manager_msg_handler_flooding (manager_msg_t *pmsg)
{
	printf("%s()"LINE_TERM, __FUNCTION__);
	led_com_toggle;

	return true;
}

bool manager_msg_handler_tbl_init(void)
{
	for (uint32_t i = 0 ; i < MANAGER_MSG_END ; i++) {
		manager_msg_handler_tbl[i] = manager_msg_handler_default;
	}

	manager_msg_handler_tbl[MANAGER_MSG_ADC_READ]		= manager_msg_handler_adc_read;
	manager_msg_handler_tbl[MANAGER_MSG_IMS]			= manager_msg_handler_ims_data;
	manager_msg_handler_tbl[MANAGER_MSG_DATA_SHOW]		= manager_msg_handler_data_show;
	manager_msg_handler_tbl[MANAGER_MSG_EMER_BTN]		= manager_msg_handler_emer_btn;
	manager_msg_handler_tbl[MANAGER_MSG_FIRE_DOOR]		= manager_msg_handler_fire_door;
	manager_msg_handler_tbl[MANAGER_MSG_AED_DOOR]		= manager_msg_handler_aed_door;
	manager_msg_handler_tbl[MANAGER_MSG_FLOODING]		= manager_msg_handler_flooding;

	return true;
}


