/**
 ******************************************************************************
 * File Name          : func_iap.c
 * Description        : This file is generated by 위대한 송 인재 on Feb 6, 2025
 ******************************************************************************
 *
 * COPYRIGHT(c) 2024 LMS Co. Ltd.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *   1. Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *   3. Neither the name of STMicroelectronics nor the names of its contributors
 *      may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************
 */

#include "main.h"

#define IAP_SEND_QUEUE_SIZE		128

extern DMA_HandleTypeDef 		hdma_usart1_rx;
extern iap_msg_func				iap_msg_handler[IAP_MSG_END];
extern iap_se_func				iap_se_machine[IAP_STATE_END][YPKT_EVENT_END];

extern DMA_HandleTypeDef hdma_uart4_rx;
extern DMA_HandleTypeDef hdma_uart4_tx;
bool SOH_req_begin ();

bool iapObj_init(iapObj_t *iapObjp)
{
	memset ((void *)iapObjp, 0, sizeof(iapObj_t));

	return true;
}

osMemoryPoolId_t iap_mpool_open (uint32_t block_count, uint32_t block_size)
{
	osMemoryPoolId_t mpId;
	mpId = osMemoryPoolNew(block_count, block_size, NULL);
	assert (mpId != NULL);
	return mpId;
}

bool iap_channel_open (UART_HandleTypeDef *huart)
{
	uint8_t *mpool;
	// Solar Stay 는 USART4 가 Raspberry 의 IAP channel 과 연결된다.
	assert (huart->Instance == UART4);

	/* Clean the input path */
	assert (HAL_UART_AbortReceive_IT(huart) == HAL_OK);
	__HAL_UART_FLUSH_DRREGISTER(huart);
	mpool = (uint8_t *)malloc(IAP_MSG_LENGTH_MAX);
	assert (mpool != NULL);
	memset ((void *)mpool, 0xff, IAP_MSG_LENGTH_MAX);
	assert (HAL_UARTEx_ReceiveToIdle_DMA(huart, mpool, IAP_MSG_LENGTH_MAX) == HAL_OK);
	iapObj.Iap_Rx_mpool = mpool;
	__HAL_DMA_DISABLE_IT(&hdma_uart4_rx, DMA_IT_HT);
	HAL_NVIC_EnableIRQ(UART4_IRQn);
	return true;
}

bool iap_channel_close (UART_HandleTypeDef *huart)
{
	assert (HAL_UART_AbortReceive_IT(huart) == HAL_OK);
	/* Clean the input path */
	__HAL_UART_FLUSH_DRREGISTER(huart);

	HAL_NVIC_DisableIRQ(UART4_IRQn);
	return true;
}

static ypkt_event_t packet_sort(ymodem_packet_t *yPacketp, uint16_t packet_size)
{
	uint16_t crc_in_packet;
	uint16_t crc_calculated;
	soh_packet_t *soh_packetp;
	stx_packet_t *stx_packetp;
	can_packet_t *can_packetp;
	ypkt_event_t ypkt_event = YPKT_EVENT_SPL;

	switch (yPacketp->type) {
	case SOH :
		soh_packetp = (soh_packet_t *)yPacketp;
		if (soh_packetp->seq != (soh_packetp->seq_oc ^ NEGATIVE_BYTE)) ypkt_event = YPKT_EVENT_SPL;
		else {	/* Check packet CRC */
			crc_in_packet = soh_packetp->crc_high8 << 8;
			crc_in_packet += soh_packetp->crc_low8;
			crc_calculated = Cal_CRC16(&soh_packetp->pkt_data[0], packet_size-PACKET_OVERHEAD_SIZE);
			ypkt_event = (crc_in_packet == crc_calculated)?YPKT_EVENT_SOH:YPKT_EVENT_SPL;
		}
		break;

	case STX :
		stx_packetp = (stx_packet_t *)yPacketp;
		if (stx_packetp->seq != (stx_packetp->seq_oc ^ NEGATIVE_BYTE)) ypkt_event = YPKT_EVENT_SPL;
		else {	/* Check packet CRC */
			crc_in_packet = stx_packetp->crc_high8 << 8;
			crc_in_packet += stx_packetp->crc_low8;
			crc_calculated = Cal_CRC16(&stx_packetp->pkt_data[0], packet_size-PACKET_OVERHEAD_SIZE);
			ypkt_event = (crc_in_packet == crc_calculated)?YPKT_EVENT_STX:YPKT_EVENT_SPL;
		}
		break;

	case CA :
		// CANCEL packet 은 10Byte 로 아래와 같다.
		// 18 18 18 18 18 08 08 08 08 08
		if (packet_size != 10) ypkt_event = YPKT_EVENT_SPL;
		else {
			can_packetp = (can_packet_t *)yPacketp;
			if (can_packetp->byte_1 != 0x18) ypkt_event = YPKT_EVENT_SPL;
			else if (can_packetp->byte_2 != 0x18) ypkt_event = YPKT_EVENT_SPL;
			else if (can_packetp->byte_3 != 0x18) ypkt_event = YPKT_EVENT_SPL;
			else if (can_packetp->byte_4 != 0x18) ypkt_event = YPKT_EVENT_SPL;
			else if (can_packetp->byte_5 != 0x08) ypkt_event = YPKT_EVENT_SPL;
			else if (can_packetp->byte_6 != 0x08) ypkt_event = YPKT_EVENT_SPL;
			else if (can_packetp->byte_7 != 0x08) ypkt_event = YPKT_EVENT_SPL;
			else if (can_packetp->byte_8 != 0x08) ypkt_event = YPKT_EVENT_SPL;
			else if (can_packetp->byte_9 != 0x08) ypkt_event = YPKT_EVENT_SPL;
			else ypkt_event = YPKT_EVENT_CAN;
		}
		break;

	case EOT :
		// EOT packet 은 size 가 1 로 온다.
		if (packet_size == 1) ypkt_event = YPKT_EVENT_EOT;
		else ypkt_event = YPKT_EVENT_SPL;
		break;

	default :
		//		printf("\r\n : UNDEFINED TYPE");
		ypkt_event = YPKT_EVENT_SPL;
		break;
	}

	return ypkt_event;
}

static bool iap_ypacket_handler(iap_msg_t *iap_msgp)
{
	ymodem_packet_t *yPacketp = (ymodem_packet_t *)iap_msgp->body.mpool;
	ypkt_event_t packet_type = packet_sort(yPacketp, iap_msgp->head.len);

	iap_se_machine[iapObj.iap_state][packet_type](yPacketp, iap_msgp->head.len);
	assert (SOH_req_begin() == true);

	return true;
}

static bool iap_SOH_req_handler(iap_msg_t *iap_msgp)
{
	if (iapObj.iap_state == IAP_STATE_SOH) {
		Serial_PutByte(CRC16);
	}
	assert (SOH_req_begin() == true);
	return true;
}

static bool iap_tpacket_handler(iap_msg_t *iap_msgp)
{
	printf("%s()"LINE_TERM, __FUNCTION__);
	return true;
}

static bool iap_msg_handler_default(iap_msg_t *iap_msgp)
{
	char iap_msg[100];

	switch (iap_msgp->head.type) {
	case IAP_MSG_BASE :				strcpy (iap_msg, "IAP_MSG_BASE"); break;
	case IAP_MSG_SOH_REQ_TIMEOUT :	strcpy (iap_msg, "IAP_MSG_SOH_REQ_TIMEOUT"); break;
	case IAP_MSG_YMODEM_PKT :		strcpy (iap_msg, "IAP_MSG_YMODEM_PKT"); break;
	case IAP_MSG_TEST_PKT :			strcpy (iap_msg, "IAP_MSG_TEST_PKT"); break;
	case IAP_MSG_END :				strcpy (iap_msg, "IAP_MSG_END"); break;
	default : assert (0 == 1); break;
	}

	printf("iap_msg = %s"LINE_TERM, iap_msg);
	HexDump(0, (void *)iap_msgp, iap_msgp->head.len);
	return true;
}

bool iap_msg_handler_init(iap_msg_func *piap_msg_handler)
{
	for (uint32_t i = 0 ; i < IAP_MSG_END ; i++) {
		piap_msg_handler[i] = iap_msg_handler_default;
	}

	piap_msg_handler[IAP_MSG_SOH_REQ_TIMEOUT] = iap_SOH_req_handler;
	piap_msg_handler[IAP_MSG_YMODEM_PKT] = iap_ypacket_handler;
	piap_msg_handler[IAP_MSG_TEST_PKT] = iap_tpacket_handler;

	return true;
}

HAL_StatusTypeDef Serial_PutByte( uint8_t param )
{
	HAL_UART_Transmit(&huart4, &param, 1, 10);
	return HAL_OK;
}


