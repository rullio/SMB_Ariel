/**
 ******************************************************************************
  * File Name          : func_rb_report.c
  * Description        : This file is generated by 위대한 송 인재 on Mar 14, 2025
 ******************************************************************************
 *
 * COPYRIGHT(c) 2024 DSN Co. Ltd.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *   1. Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *   3. Neither the name of STMicroelectronics nor the names of its contributors
 *      may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************
 */

#include "main.h"

#define RB_SEND_QUEUE_SIZE		128

static rb_report_t rb_report;
PLACE_IN_SECTION ("mram") static queue_t RbSendQueue;
PLACE_IN_SECTION ("mram") static uint8_t RbSendQueueBuff[RB_SEND_QUEUE_SIZE];
static __IO ITStatus RbSendPeripheralReady = SET;

static void Rb_TxCpltCallback(void);
static size_t send_report_to_rb (unsigned char *buf, size_t bufSize);
static void tx2rb_output(  uint8_t *p_data, uint16_t size, void (*cb)(void) );

bool sb_report_to_rb (rb_head_type_t type, uint32_t value)
{
	// RB 가 살아 있는 상태에서만 report 를 보낸다.
	if (SMB_StatusObj.rb_working != true) return true;

	memset (&rb_report, 0, sizeof(rb_report));

	rb_report.type = type;

	switch (rb_report.type) {
	case RB_REPORT_SENSOR_STATUS :
		rb_report.len = 4;
		rb_sensor_status_t *rssp = (rb_sensor_status_t *)rb_report.body;
		rssp->emer_btn = get_emer_btn_status;
		rssp->aed_door = get_aed_door_status;
		rssp->fire_door = get_fire_door_status;
		rssp->flood = get_flood_status;
		rssp->siren = SMB_ControlObj.sirenObj.siren_flag;
		rssp->lamp = (SMB_ControlObj.lampObj.lamp_level == LAMP_LEVEL_0)?0:1;
		rssp->ltepwr = SMB_ControlObj.lteObj.lte_flag;
		rssp->ptc = SMB_ControlObj.ptcObj.ptc_flag;
		rssp->fan = SMB_ControlObj.fanObj.fan_flag;
		rssp->yuchar = SMB_ControlObj.yucharObj.yuchar_flag;
		rssp->muchar1 = SMB_ControlObj.muchar1Obj.muchar1_flag;
		rssp->muchar2 = SMB_ControlObj.muchar2Obj.muchar2_flag;
		rssp->charger = 0;		// 이거를 audio 로 바꾸면 어떨까???
		rssp->inverter = SMB_ControlObj.inverterObj.inverter_flag;
		rssp->rsvd = 0;
		break;

	case RB_REPORT_YUIW :
		rb_report.len = 4;
		*(uint32_t *)rb_report.body = SMB_adc_value.YUI;
		break;

	case RB_REPORT_MUI1W :
		rb_report.len = 4;
		*(uint32_t *)rb_report.body = SMB_adc_value.MUI1;
		break;

	case RB_REPORT_MUI2W :
		rb_report.len = 4;
		*(uint32_t *)rb_report.body = SMB_adc_value.MUI2;
		break;

	case RB_REPORT_AEDT :
		rb_report.len = 4;
		*(uint32_t *)rb_report.body = SMB_adc_value.AEDT;
		break;

	case RB_REPORT_CDS :
		rb_report.len = 4;
		*(uint32_t *)rb_report.body = SMB_adc_value.CDS;
		break;

	case RB_REPORT_LEDBAR_COLOR :
		rb_report.len = 4;
		rb_report.body[0] = SMB_ControlObj.ledbarObj.ledbar_color;
		break;

	case RB_REPORT_EMER_BTN_PRESS :
	case RB_REPORT_FIRE_DOOR_OPEN :
	case RB_REPORT_AED_DOOR_OPEN :
	case RB_REPORT_FLOOD_HAPPEN :
		rb_report.len = 1;
		rb_report.body[0] = 1;
		break;

	case RB_REPORT_EMER_BTN_RELEASE :
	case RB_REPORT_FIRE_DOOR_CLOSED :
	case RB_REPORT_AED_DOOR_CLOSED :
	case RB_REPORT_FLOOD_CLEAR :
		rb_report.len = 1;
		rb_report.body[0] = 0;
		break;

	case RB_REPORT_HW_VERSION :
		rb_report.len = 1;
		*(uint32_t *)rb_report.body = value;
		break;

	default :
		assert (0 == 1);
		break;
	}
	rb_report.checksum = checksum((uint8_t *)&rb_report, 6);
	rb_report.end_marker = END_MARKER;

	assert (osSemaphoreAcquire(sem_rb_tx, osWaitForever) == osOK);
	assert (send_report_to_rb((unsigned char *)&rb_report, sizeof(rb_report)) == sizeof(rb_report));
	assert (osSemaphoreRelease(sem_rb_tx) == osOK);

	return true;
}

bool RbSendQueueBuffInit(void)
{
	memset(RbSendQueueBuff, 0, sizeof(RbSendQueueBuff));
	CircularQueue_Init(&RbSendQueue, RbSendQueueBuff, RB_SEND_QUEUE_SIZE, 0, CIRCULAR_QUEUE_SPLIT_IF_WRAPPING_FLAG);
	return true;
}

static void Rb_TxCpltCallback(void)
{
	uint8_t *buf;
	uint16_t bufSize;

	BACKUP_PRIMASK();

	DISABLE_IRQ();
	CircularQueue_Remove(&RbSendQueue, &bufSize);

	buf = CircularQueue_Sense(&RbSendQueue, &bufSize);

	if (buf != NULL) {
		RESTORE_PRIMASK();
		tx2rb_output((uint8_t*)buf, bufSize, Rb_TxCpltCallback);
	} else {
		RbSendPeripheralReady = SET;
		RESTORE_PRIMASK();
	}
}

static size_t send_report_to_rb (unsigned char *buf, size_t bufSize)
{
	size_t chars_sent = 0;
	uint8_t *buffer;

	BACKUP_PRIMASK();

	if (bufSize != 0) {
		chars_sent = bufSize;

		DISABLE_IRQ();
		buffer = CircularQueue_Add(&RbSendQueue, (uint8_t*)buf, bufSize, 1);
		if (buffer && RbSendPeripheralReady) {
			RbSendPeripheralReady = RESET;
			RESTORE_PRIMASK();
			tx2rb_output((uint8_t*) buffer, bufSize, Rb_TxCpltCallback);
		} else {
			RESTORE_PRIMASK();
		}
	}
	return (chars_sent);
}

static void tx2rb_output(  uint8_t *p_data, uint16_t size, void (*cb)(void) )
{
	assert (HW_UART_Transmit_DMA(hw_usart2, p_data, size, cb) == hw_uart_ok);
	return;
}


