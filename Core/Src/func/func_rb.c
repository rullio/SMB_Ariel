/**
 ******************************************************************************
 * File Name          : func_rb.c
 * Description        : This file is generated by 위대한 송 인재 on Feb 7, 2025
 ******************************************************************************
 *
 * COPYRIGHT(c) 2024 LMS Co. Ltd.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *   1. Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *   3. Neither the name of STMicroelectronics nor the names of its contributors
 *      may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************
 */

#include "main.h"

extern rb_msg_func				rb_msg_handler_tbl[];
extern uint8_t 					Rb_Rx_Buf[];
extern DMA_HandleTypeDef hdma_usart2_rx;
extern DMA_HandleTypeDef hdma_usart2_tx;

__IO ITStatus RbChanReady = SET;

bool rb_channel_open (UART_HandleTypeDef *huart)
{
	// Solar Stay 는 USART2 가 Raspberry 와 연결된다.
	assert (huart->Instance == USART2);

	/* Clean the input path */
	assert (HAL_UART_AbortReceive_IT(huart) == HAL_OK);
	__HAL_UART_FLUSH_DRREGISTER(huart);
	assert (HAL_UARTEx_ReceiveToIdle_DMA(huart, Rb_Rx_Buf, RB_MSG_SIZE) == HAL_OK);
	__HAL_DMA_DISABLE_IT(&hdma_usart2_rx, DMA_IT_HT);
	__HAL_DMA_DISABLE_IT(&hdma_usart2_tx, DMA_IT_HT);
	HAL_NVIC_EnableIRQ(USART2_IRQn);

	return true;
}

bool rb_channel_close ()
{
	assert (HAL_UART_AbortReceive_IT(&RbUartHandle) == HAL_OK);
	/* Clean the input path */
	__HAL_UART_FLUSH_DRREGISTER(&RbUartHandle);

	HAL_NVIC_DisableIRQ(USART2_IRQn);
	return true;
}

static bool rb_msg_handler_default(rb_msg_t *pq_msg)
{
	char rb_msg[100];

	switch (pq_msg->head.type) {
	case RB_MSG_BASE :			strcpy (rb_msg, "RB_MSG_BASE"); break;
	case RB_MSG_COMMAND :		strcpy (rb_msg, "RB_MSG_CONTROL"); break;
	default : assert (0 == 1); break;
	}

	printf("%s() : rb_msg = %s"LINE_TERM, __FUNCTION__, rb_msg);

	return true;
}

bool rb_msg_build_up (rb_msg_t *rbmp, RB_Msg_type_t type, WorkModule_Entity_t dst, WorkModule_Entity_t src, uint8_t len, rb_head_type_t rb_head_type)
{
	rbmp->head.type = type;
	rbmp->head.dst = dst;
	rbmp->head.src = src;
	rbmp->head.len = len;

	rbmp->rb_command.type = rb_head_type;
	rbmp->rb_command.checksum = checksum((uint8_t *)&rbmp->rb_command, 6);
	rbmp->rb_command.end_marker = END_MARKER;
	return true;
}

bool rb_msg_handler_tbl_init()
{
	for (uint32_t i = 0 ; i < RB_MSG_END ; i++) {
		rb_msg_handler_tbl[i] = rb_msg_handler_default;
	}

	rb_msg_handler_tbl[RB_MSG_COMMAND] = rb_cmd_handler;

	assert (rb_command_handler_tbl_init() == true);

	return true;
}

/*******************************************************************************
 * Calculate checksum for raspberry communication..
 *******************************************************************************/
uint8_t checksum(uint8_t *addr, uint8_t count)
{
	uint8_t sum = 0;
	uint8_t i;
	for (i = 0; i < count; i++) sum += *addr++;
	return (~sum);
}


