/**
 ******************************************************************************
 * File Name          : func_rtc.c
 * Description        : This file is generated by 위대한 송 인재 on Aug 26, 2025
 ******************************************************************************
 *
 * COPYRIGHT(c) 2024 DSN Co. Ltd.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *   1. Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *   3. Neither the name of STMicroelectronics nor the names of its contributors
 *      may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************
 */

#include "main.h"

void doSystemReset();

void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
{
	RTC_AlarmTypeDef sAlarm;
	RTC_TimeTypeDef sTime = {0};

	assert (HAL_RTC_GetTime(hrtc, &sTime, RTC_FORMAT_BIN) == HAL_OK);
	HAL_RTC_GetAlarm(hrtc, &sAlarm, RTC_ALARM_A, RTC_FORMAT_BIN);
	sAlarm.AlarmTime.Minutes = sTime.Minutes + 1;
	sAlarm.AlarmTime.Minutes %= 60;
	assert (HAL_RTC_SetAlarm_IT(hrtc, &sAlarm, RTC_FORMAT_BIN) == HAL_OK);

	printf("%s()"LINE_TERM, __FUNCTION__);
	//	1분 마다 RTC Alarm A 를 받게 되는데 이것을 어떻게 활용할 것인가? Smart Bench 운용 상황을 보아 가면서 결정할 것.

	return;
}

// HAL_RTC_AlarmAEventCallback() 을 베껴서 HAL_RTC_AlarmBEventCallback() 로 쓰는 것을 주의할 것.
// 실제로는 HAL_RTCEx_AlarmBEventCallback() 을 사용해야 하기 때문이다.
// RTC Alarm A 와 RTC Alarm B 는 callback 함수의 이름이 약간 다름에 주의할 것.
void HAL_RTCEx_AlarmBEventCallback(RTC_HandleTypeDef *hrtc)
{
	RTC_AlarmTypeDef sAlarm;
	HAL_RTC_GetAlarm(hrtc, &sAlarm, RTC_ALARM_B, RTC_FORMAT_BIN);
	assert (HAL_RTC_SetAlarm_IT(hrtc, &sAlarm, RTC_FORMAT_BIN) == HAL_OK);

	doSystemReset();

	return;
}

bool SMB_RTC_Init(void)
{
	RTC_TimeTypeDef sTime = {0};
	RTC_DateTypeDef sDate = {0};

	/** Initialize RTC Only
	 */
	hrtc.Instance = RTC;
	hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
	hrtc.Init.AsynchPrediv = 127;
	hrtc.Init.SynchPrediv = 255;
	hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
	hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
	hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
	hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
	assert (HAL_RTC_Init(&hrtc) == HAL_OK);

	/** Initialize RTC and set the Time and Date
	 */
	sTime.Hours = 0x23;
	sTime.Minutes = 0x59;
	sTime.Seconds = 0x50;
	sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
	sTime.StoreOperation = RTC_STOREOPERATION_RESET;
	assert (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) == HAL_OK);

	sDate.WeekDay = RTC_WEEKDAY_TUESDAY;
	sDate.Month = RTC_MONTH_AUGUST;
	sDate.Date = 0x26;
	sDate.Year = 0x25;
	assert (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) == HAL_OK);

	return true;
}

bool SMB_set_alarm_a()
{
	RTC_TimeTypeDef sTime = {0};
	RTC_AlarmTypeDef sAlarm = {0};
	/** Enable the Alarm A.. 1 min later from now ..
	 */

	assert (HAL_RTC_GetTime(&hrtc, &sTime, RTC_FORMAT_BIN) == HAL_OK);

	sAlarm.AlarmTime.Hours = 0x0;
	sAlarm.AlarmTime.Minutes = sTime.Minutes + 1;
	sAlarm.AlarmTime.Seconds = 0x0;
	sAlarm.AlarmTime.SubSeconds = 0x0;
	sAlarm.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
	sAlarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
	sAlarm.AlarmMask = RTC_ALARMMASK_DATEWEEKDAY|RTC_ALARMMASK_HOURS
			|RTC_ALARMMASK_SECONDS;
	sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
	sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
	sAlarm.AlarmDateWeekDay = 0x1;
	sAlarm.Alarm = RTC_ALARM_A;
	assert (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) == HAL_OK);
	return true;
}

bool SMB_set_alarm_b()
{
	RTC_AlarmTypeDef sAlarm = {0};
	/** Enable the Alarm B
	 * 매달 1일 새벽 1시 59분 59초에 RTC Alarm B 가 뜨고 rebooting 한다.
	 */

	sAlarm.AlarmTime.Hours = 0x1;
	sAlarm.AlarmTime.Minutes = 0x59;
	sAlarm.AlarmTime.Seconds = 0x59;
	sAlarm.AlarmTime.SubSeconds = 0x0;
	sAlarm.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
	sAlarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
	sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
	sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
	sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
	sAlarm.AlarmDateWeekDay = 0x1;
	sAlarm.Alarm = RTC_ALARM_B;
	assert (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) == HAL_OK);
	return true;
}

bool SMB_1sec_alarm_restart()
{
	RTC_TimeTypeDef sTime = {0};
	RTC_AlarmTypeDef sAlarm = {0};

	assert (HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A) == HAL_OK);
	assert (HAL_RTC_GetTime(&hrtc, &sTime, RTC_FORMAT_BIN) == HAL_OK);

	sAlarm.AlarmTime = sTime;
	sAlarm.AlarmTime.Minutes += 1;	// 1분마다 alarm 을 받아서 lamp duty 를 check 한다.
	sAlarm.AlarmTime.Minutes %= 60;
	sAlarm.AlarmMask = RTC_ALARMMASK_DATEWEEKDAY|RTC_ALARMMASK_HOURS|RTC_ALARMMASK_SECONDS;
	sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
	sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
	sAlarm.Alarm = RTC_ALARM_A;

	assert (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BIN) == HAL_OK);

	return true;
}
