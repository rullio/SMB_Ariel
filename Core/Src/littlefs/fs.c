/**
 ******************************************************************************
 * File Name          : fs.c
 * Description        : This file is generated by 위대한 송 인재 for AmigoB_alpha.
 ******************************************************************************
 *
 * COPYRIGHT(c) 2024 LMS Co. Ltd.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *   1. Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *   3. Neither the name of STMicroelectronics nor the names of its contributors
 *      may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************
 */

#include "main.h"

lfs_t lfs;
lfs_file_t file;
bool	IsFS_mount = false;
#define LFS_CACHE_SIZE	256U
#define LOOK_AHEAD_CACHE_SIZE	(256/8U)
#ifdef LFS_THREADSAFE
static osMutexId_t lfs_mutex;
#endif
static int32_t is_init = false;

static uint8_t read_buffer[LFS_CACHE_SIZE];
static uint8_t prog_buffer[LFS_CACHE_SIZE];
static uint8_t lookahead_buffer[LOOK_AHEAD_CACHE_SIZE];

static int fsDeviceRead(const struct lfs_config *c, lfs_block_t block, lfs_off_t off, void *buffer, lfs_size_t size);
static int fsDeviceProg(const struct lfs_config *c, lfs_block_t block, lfs_off_t off, const void *buffer, lfs_size_t size);
static int fsDeviceErase(const struct lfs_config *c, lfs_block_t block);
static int fsDeviceSync(const struct lfs_config *c);

#ifdef LFS_THREADSAFE
static int fsDeviceLock(const struct lfs_config *c);
static int fsDeviceUnlock(const struct lfs_config *c);
#endif

// configuration of the filesystem is provided by this struct
struct lfs_config smb_lfs_config = {
		// block device operations
		.read  = fsDeviceRead,
		.prog  = fsDeviceProg,
		.erase = fsDeviceErase,
		.sync  = fsDeviceSync,
#ifdef LFS_THREADSAFE
		.lock  = fsDeviceLock,
		.unlock  = fsDeviceUnlock,
#endif
		// GD25Q128E 는 256B 짜리 page 16 개가 1개의 sector 를 이룬다
		.read_size = LFS_CACHE_SIZE,		// read
		.prog_size = LFS_CACHE_SIZE,		// write
		.block_size = 4096,					// GD25Q128E 1개의 sector 는 4,096Byte
		.block_count = 4096,				// GD25Q128E 는 4,096 개의 sector (지울 수 있는 단위)
		.cache_size = LFS_CACHE_SIZE,
		.lookahead_size = LOOK_AHEAD_CACHE_SIZE,	// lookahead_buffer[] 의 크기와 동일하게 맞출 것.
		.block_cycles = 100000,				// GD25Q128E datasheet says Minimum 100,000 Program/Erase Cycles

		// Optional statically allocated read buffer. Must be cache_size.
		// By default lfs_malloc is used to allocate this buffer.
		.read_buffer = read_buffer,

		// Optional statically allocated program buffer. Must be cache_size.
		// By default lfs_malloc is used to allocate this buffer.
		.prog_buffer = prog_buffer,

		// Optional statically allocated lookahead buffer. Must be lookahead_size
		// and aligned to a 32-bit boundary. By default lfs_malloc is used to
		// allocate this buffer.
		.lookahead_buffer = lookahead_buffer
};

bool LittleFS_init(void)
{
	int err;

#ifdef LFS_THREADSAFE
	lfs_mutex = osMutexNew(NULL);
	assert (lfs_mutex != NULL);
#endif

	// CLI thread 에서 여러 파일을 한꺼번에 지울 때 위의 mutex 만으로는 thread 간에 완전한 mutexing 이 안되는 듯..
	// 여러 파일을 지우면서 reset 되는 현상 발생..
	// 그래서 thread mutexing 을 위해 semaphore 를 하나 추가해 봄.

	err = lfs_mount(&lfs, &smb_lfs_config);

	if (err == LFS_ERR_OK) {
		IsFS_mount = true;
		return true;
	}
	// reformat if we can't mount the filesystem
	// this should only happen on the first boot
	else {
		assert (lfs_format(&lfs, &smb_lfs_config) == LFS_ERR_OK);
		assert (lfs_mount(&lfs, &smb_lfs_config) == LFS_ERR_OK);
		IsFS_mount = true;
		return true;
	}
}

int32_t fsIsExist(const char *name)
{
	bool ret = false;
	int err;
	struct lfs_info info;

	err = lfs_stat(&lfs, name, &info);
	if (err == LFS_ERR_OK) {
		ret = true;
	}

	return ret;
}

int32_t fsIsDir(const char *dirname)
{
	int err;
	lfs_dir_t lfs_dir;

	err = lfs_dir_open(&lfs, &lfs_dir, dirname);
	if (err < 0) {
		return false;
	}
	return true;
}

int32_t fsGetFree(void)
{
	int free_size = 0;
	int used_count = 0;

	used_count = lfs_fs_size(&lfs);

	if (used_count > 0)	{
		free_size = (lfs.cfg->block_count - used_count) * lfs.cfg->block_size;
	}
	else {
		free_size = 0;
	}

	return (int32_t)free_size;
}

int32_t fsGetSize(void)
{
	return lfs.cfg->block_count * lfs.cfg->block_size;
}

int32_t fsFileOpen(fs_t *p_fs, const char *name)
{
	bool ret = false;
	int err;

	p_fs->is_open = false;

	err = lfs_file_open(&lfs, &p_fs->file, name, LFS_O_RDWR | LFS_O_CREAT);
	if (err == LFS_ERR_OK) {
		ret = true;
		p_fs->is_open = true;
	}

	return ret;
}

int32_t fsFileClose(fs_t *p_fs)
{
	bool ret = false;
	int err;

	if (p_fs->is_open != true) {
		return false;
	}

	err = lfs_file_close(&lfs, &p_fs->file);
	if (err == LFS_ERR_OK) {
		ret = true;
	}

	p_fs->is_open = false;

	return ret;
}

int32_t fsFileDel(const char *filename)
{
	int err = 0;

	if (is_init != true) {
		return false;
	}

	err = lfs_remove(&lfs, filename);
	if(err < 0) {
		return false;
	}

	return true;
}

int32_t fsFileRead(fs_t *p_fs, uint8_t *p_data, uint32_t length)
{
	int32_t ret;

	if (p_fs->is_open != true) {
		return false;
	}

	ret = lfs_file_read(&lfs, &p_fs->file, p_data, length);

	return ret;
}

int32_t fsFileWrite(fs_t *p_fs, uint8_t *p_data, uint32_t length)
{
	int32_t ret;

	if (p_fs->is_open != true) {
		return 0;
	}

	ret = lfs_file_write(&lfs, &p_fs->file, p_data, length);

	return ret;
}

int32_t fsFileSync(fs_t *p_fs)
{
	return lfs_file_sync(&lfs, &p_fs->file);
}

int32_t fsFileRewind(fs_t *p_fs)
{
	bool ret = false;

	if (p_fs->is_open != true) {
		return false;
	}

	if (lfs_file_rewind(&lfs, &p_fs->file) == LFS_ERR_OK) {
		ret = true;
	}

	return ret;
}

int32_t fsFileSeek(fs_t *p_fs, uint32_t seek_pos)
{
	int32_t ret;

	ret = lfs_file_seek(&lfs, &p_fs->file, seek_pos, LFS_SEEK_SET);

	return ret;
}

int32_t fsFileSize(fs_t *p_fs)
{
	int32_t ret;

	ret = lfs_file_size(&lfs, &p_fs->file);

	return ret;
}

// Read a region in a block. Negative error codes are propogated
// to the user.
int fsDeviceRead(const struct lfs_config *c, lfs_block_t block,	lfs_off_t off, void *buffer, lfs_size_t size)
{
	int err = LFS_ERR_OK;
	bool ret;
	uint32_t addr;
	SPIF_HandleTypeDef *Handle = &spif_handle;

	addr = block * c->block_size + off;
	ret = SPIF_ReadAddress(Handle, addr, (uint8_t *)buffer, size);

	if (ret != true) {
		err = -100;
	}

	return err;
}

// Program a region in a block. The block must have previously
// been erased. Negative error codes are propogated to the user.
// May return LFS_ERR_CORRUPT if the block should be considered bad.
int fsDeviceProg(const struct lfs_config *c, lfs_block_t block,	lfs_off_t off, const void *buffer, lfs_size_t size)
{
	int err = LFS_ERR_OK;
	bool ret;
	SPIF_HandleTypeDef *Handle = &spif_handle;

	ret = SPIF_WriteSector(Handle, block, (uint8_t *)buffer, size, off);
	if (ret != true) {
		err = -101;
	}

	return err;
}

// Erase a block. A block must be erased before being programmed.
// The state of an erased block is undefined. Negative error codes
// are propogated to the user.
// May return LFS_ERR_CORRUPT if the block should be considered bad.
int fsDeviceErase(const struct lfs_config *c, lfs_block_t block)
{
	int err = LFS_ERR_OK;
	bool ret;
	SPIF_HandleTypeDef *Handle = &spif_handle;

	ret = SPIF_EraseSector(Handle, block);

	if (ret != true) {
		err = -102;
	}

	return err;
}

// Sync the state of the underlying block device. Negative error codes
// are propogated to the user.
int fsDeviceSync(const struct lfs_config *c)
{
	int err = LFS_ERR_OK;

	return err;
}

#ifdef LFS_THREADSAFE
// fs locking mutex acquire
uint32_t fsDeviceLock_fail_count = 0;
int fsDeviceLock(const struct lfs_config *c)
{
	osStatus_t  status;
	int err = LFS_ERR_OK;

//	문제가 있는 것처럼 보여서 timeout 값을 줘서 돌려 보기로 함. Jay
	status = osMutexAcquire(lfs_mutex, osWaitForever);
	if (status != osOK) {
		err = -1;
		fsDeviceLock_fail_count++;
	}

	return err;
}

// fs unlocking mutex release
int fsDeviceUnlock(const struct lfs_config *c)
{
	osStatus_t  status;
	int err = LFS_ERR_OK;

	status = osMutexRelease(lfs_mutex);
	if (status != osOK) {
		err = -1;
	}

	return err;
}
#endif
