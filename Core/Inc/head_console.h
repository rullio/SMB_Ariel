/**
 ******************************************************************************
 * File Name          : head_console.h
 * Description        : This file is generated by 위대한 송 인재.
 ******************************************************************************
 *
 * COPYRIGHT(c) 2024 Daeshin Networks Co. Ltd.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *   1. Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *   2. Redistributions in binary form must reproduce the above copyright notice,
 *      this list of conditions and the following disclaimer in the documentation
 *      and/or other materials provided with the distribution.
 *   3. Neither the name of STMicroelectronics nor the names of its contributors
 *      may be used to endorse or promote products derived from this software
 *      without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 ******************************************************************************
 */

#ifndef INC_HEAD_HEAD_CONSOLE_H_

#define INC_HEAD_HEAD_CONSOLE_H_

#define         LINE_TERM       "\r\n"          // line terminator
#define         _promptStr      "\x1b[0mSMB_Ariel>"             // prompt string

// *****************************************************************************
// console control.. copied from TI..
// *****************************************************************************
#define CUI_ESC_UP              "\033[A"
#define CUI_ESC_DOWN            "\033[B"
#define CUI_ESC_RIGHT           "\033[C"
#define CUI_ESC_LEFT            "\033[D"
#define CUI_ESC_ESC             "\033\0\0\0\0"
//
// *
// * Escape sequences for terminal control.
// * Any sequences with '%' in them require require additional information to be used
// *  as is.
// *
#define CUI_ESC_TRM_MODE            "\033[20"    // Set line feed mode for the terminal
#define CUI_ESC_CLR                 "\033[2J"    // Clear the entire screen
#define CUI_ESC_CLR_UP              "\033[1J"    // Clear screen from cursor up
#define CUI_ESC_CLR_STAT_LINE_VAL   "\033[2K"    // Clear the status line

#define CUI_ESC_CUR_HIDE            "\033[?25l"  // Hide cursor
#define CUI_ESC_CUR_SHOW            "\033[?25h"  // Show cursor
#define CUI_ESC_CUR_HOME            "\033[H"     // Move cursor to the top left of the terminal
#define CUI_ESC_CUR_MENU_BTM        "\033[3;%dH" // Move cursor to the bottom right of the menu
#define CUI_ESC_CUR_LINE            "\033[%d;0H" // Move cursor to a line of choice
#define CUI_ESC_CUR_ROW_COL         "\033[%d;%dH"// Move cursor to row and col

#define		SYS_CMD_DEVICE_MAX_INSTANCES		1
#define		SYS_CMD_MAX_LENGTH					80
#define		SYS_CMD_READ_BUFFER_SIZE 128
#define		MAX_CMD_GROUP   					12
#define		MAX_CMD_ARGS    					8
#define		COMMAND_HISTORY_DEPTH   			12
// standard VT100 key escape sequences
#define		VT100_MAX_ESC_SEQ_SIZE				4               // max VT100 escape sequence size that is processed
#define		SYS_CONSOLE_DEVICE_MAX_INSTANCES	1
#define		SYS_CONSOLE_UART_MAX_INSTANCES		1

#define		SYS_CMD_PRINT_BUFFER_SIZE			256

#define SYS_CONSOLE_INDEX_0                       0
typedef uintptr_t CONSOLE_DEVICE_INDEX;
/* These are in unistd.h */
#define STDIN_FILENO     0
#define STDOUT_FILENO    1
#define STDERR_FILENO    2
#define SYS_CONSOLE_DEFAULT_INSTANCE    0

#define SYS_CONSOLE_PRINT(fmt, ...)                 SYS_CONSOLE_Print(SYS_CONSOLE_DEFAULT_INSTANCE, fmt, ##__VA_ARGS__)
#define SYS_CONSOLE_MESSAGE(message)                SYS_CONSOLE_Message(SYS_CONSOLE_DEFAULT_INSTANCE, message)

// *****************************************************************************
// Section: Type Definitions
// *****************************************************************************
typedef struct _tagHistCmdNode {
	struct _tagHistCmdNode* next;
	struct _tagHistCmdNode* prev;
	char    cmdBuff[SYS_CMD_MAX_LENGTH + 1];  // command itself
} histCmdNode;   // simple command history

typedef struct {
	histCmdNode*    head;
	histCmdNode*    tail;
} histCmdList;     // doubly linked history command list

typedef enum
{
	SYS_CONSOLE_STATUS_NOT_CONFIGURED,
	SYS_CONSOLE_STATUS_CONFIGURED,
	SYS_CONSOLE_STATUS_BUSY,
	SYS_CONSOLE_STATUS_ERROR
} SYS_CONSOLE_STATUS;

typedef enum
{
	SYS_CONSOLE_DEV_USART,
	SYS_CONSOLE_DEV_USB_CDC,
	SYS_CONSOLE_DEV_MAX,
} SYS_CONSOLE_DEVICE;

typedef void (*SYS_CMD_MSG_FNC)(const void* cmdIoParam, const char* str);
typedef void (*SYS_CMD_PRINT_FNC)(const void* cmdIoParam, const char* format, ...);
typedef void (*SYS_CMD_PUTC_FNC)(const void* cmdIoParam, char c);
typedef int (*SYS_CMD_DATA_RDY_FNC)(const void* cmdIoParam);
typedef char (*SYS_CMD_GETC_FNC)(const void* cmdIoParam);

typedef struct {
	SYS_CMD_MSG_FNC msg;
	SYS_CMD_PRINT_FNC print;
	SYS_CMD_PUTC_FNC  putc;
	SYS_CMD_DATA_RDY_FNC isRdy;
	SYS_CMD_GETC_FNC getc;
} SYS_CMD_API;

typedef enum {
	SYS_CMD_EVENT_WRITE_COMPLETE,
	SYS_CMD_EVENT_READ_COMPLETE,

} SYS_CMD_EVENT;

typedef enum {
	SYS_CMD_SINGLE_CHARACTER_READ_CONSOLE_IO_PARAM = 0,

} SYS_CMD_CONSOLE_IO_PARAM;

typedef enum {
	SYS_STATUS_ERROR_EXTENDED   = -10,
	SYS_STATUS_ERROR            = -1,
	SYS_STATUS_UNINITIALIZED    = 0,
	SYS_STATUS_BUSY             = 1,
	SYS_STATUS_READY            = 2,
	SYS_STATUS_READY_EXTENDED   = 10
} SYS_STATUS;

typedef union {
	uint8_t         value;
	struct {
		uint8_t     reserved    : 4;
	}sys;
} SYS_MODULE_INIT;

typedef unsigned short int SYS_MODULE_INDEX;
typedef uintptr_t SYS_MODULE_OBJ;
#define SYS_MODULE_OBJ_INVALID      ((SYS_MODULE_OBJ) -1 )
#define SYS_MODULE_OBJ_STATIC       ((SYS_MODULE_OBJ) 0 )

typedef SYS_MODULE_OBJ (* SYS_MODULE_INITIALIZE_ROUTINE) ( const SYS_MODULE_INDEX index, const SYS_MODULE_INIT * const init );
typedef void (* SYS_MODULE_REINITIALIZE_ROUTINE) ( SYS_MODULE_OBJ object, const SYS_MODULE_INIT * const init );
typedef void (* SYS_MODULE_DEINITIALIZE_ROUTINE) (  SYS_MODULE_OBJ object );
typedef SYS_STATUS (* SYS_MODULE_STATUS_ROUTINE) (  SYS_MODULE_OBJ object );
typedef void (* SYS_MODULE_TASKS_ROUTINE) ( SYS_MODULE_OBJ object );

typedef struct {
	/* System module initialization */
	SYS_MODULE_INIT     moduleInit;
	uint8_t             consoleCmdIOParam;
	/* Console index to receive debug messages */
	SYS_MODULE_INDEX    consoleIndex;
} SYS_CMD_INIT;

typedef struct {
	const SYS_CMD_API*  pCmdApi;    // Cmd IO APIs
	const void*         cmdIoParam; // channel specific parameter
} SYS_CMD_DEVICE_NODE;

typedef void (*SYS_CMD_FNC)(SYS_CMD_DEVICE_NODE* pCmdIO, int argc, char **argv);
typedef struct {
	const char*     cmdStr;        // string identifying the command
	SYS_CMD_FNC     cmdFnc;        // function to execute for this command
	const char*     cmdDescr;      // simple command description
} SYS_CMD_DESCRIPTOR;              // a simple command descriptor

// currently supported sequences received from the terminal:
// up arrow:    ESC [ A
// down arrow:  ESC [ B
// right arrow: ESC [ C
// left arrow:  ESC [ D
//
// VT100 control commands sent to the terminal:
// erase to the end of the line:    ESC [ K
// move cursor backwards:           ESC [ {COUNT} D
// move cursor forward:             ESC [ {COUNT} C
//

// descriptor of the command I/O node
typedef struct SYS_CMD_IO_DCPT {
	SYS_CMD_DEVICE_NODE devNode;
	// internally maintained data
	struct SYS_CMD_IO_DCPT* next;   // linked list node
	const struct _KEY_SEQ_DCPT* pSeqDcpt; // current escape sequence in progress
	int16_t         seqChars;   // # of characters from the escape sequence
	char            seqBuff[VT100_MAX_ESC_SEQ_SIZE + 2];     // 0x1b + escape sequence + \0
	char*           cmdPnt; // current pointer
	char*           cmdEnd; // command end
	char            cmdBuff[SYS_CMD_MAX_LENGTH + 1];   // buffer holding the command
	char            ctrlBuff[SYS_CMD_MAX_LENGTH + 10]; // buffer for terminal control
	// history
	histCmdList     histList;                           // arranged as list
	histCmdNode*    currHistN;      // current history node
	histCmdNode     histArray[COMMAND_HISTORY_DEPTH];   // array of history commands
} SYS_CMD_IO_DCPT;

// Defines the list structure to store a list of command instances.
typedef struct {
	SYS_CMD_IO_DCPT* head;
	SYS_CMD_IO_DCPT* tail;
} SYS_CMD_DEVICE_LIST;

// Defines the command table structure for the Command Processor System Service.
typedef struct {
	int                         nCmds;          // number of commands available in the table
	const SYS_CMD_DESCRIPTOR*   pCmd;      // pointer to an array of command descriptors
	const char*                 cmdGroupName;   // name identifying the commands
	const char*                 cmdMenuStr;     // help string

} SYS_CMD_DESCRIPTOR_TABLE;                 // table containing the supported commands

typedef struct {
	SYS_MODULE_OBJ  sysDebug;
	SYS_MODULE_OBJ  sysTime;
	SYS_MODULE_OBJ  sysConsole0;
} SYSTEM_OBJECTS;

bool SYS_CMD_Initialize(const SYS_MODULE_INIT * const init );
bool    SYS_CMD_ADDGRP(const SYS_CMD_DESCRIPTOR* pCmdTbl, int nCmds, const char* groupName, const char* menuStr);

typedef uintptr_t SYS_CONSOLE_HANDLE;

typedef void (*SYS_CONSOLE_INIT_FPTR) (uint32_t index, const void* initData);
typedef size_t (*SYS_CONSOLE_READ_FPTR) (uint32_t index, void* buf, size_t count);
typedef size_t (*SYS_CONSOLE_READ_FREE_BUFF_COUNT_GET_FPTR) (uint32_t index);
typedef size_t (*SYS_CONSOLE_READ_COUNT_GET_FPTR) (uint32_t index);
typedef size_t (*SYS_CONSOLE_WRITE_FPTR) (uint32_t index, const void* buf, size_t count);
typedef size_t (*SYS_CONSOLE_WRITE_FREE_BUFF_COUNT_GET_FPTR) (uint32_t index);
typedef size_t (*SYS_CONSOLE_WRITE_COUNT_GET_FPTR) (uint32_t index);
typedef void (*SYS_CONSOLE_TASK_FPTR) (uint32_t index, SYS_MODULE_OBJ object);
typedef SYS_CONSOLE_STATUS (*SYS_CONSOLE_STATUS_FPTR) (uint32_t index);
typedef bool (*SYS_CONSOLE_FLUSH_FPTR) (uint32_t index);

typedef struct {
	SYS_CONSOLE_DEVICE consoleDevice;
	SYS_CONSOLE_INIT_FPTR init;
	SYS_CONSOLE_READ_FPTR read;
	SYS_CONSOLE_READ_COUNT_GET_FPTR readCountGet;
	SYS_CONSOLE_READ_FREE_BUFF_COUNT_GET_FPTR readFreeBufferCountGet;
	SYS_CONSOLE_WRITE_FPTR write;
	SYS_CONSOLE_WRITE_COUNT_GET_FPTR writeCountGet;
	SYS_CONSOLE_WRITE_FREE_BUFF_COUNT_GET_FPTR writeFreeBufferCountGet;
	SYS_CONSOLE_STATUS_FPTR status;
	SYS_CONSOLE_FLUSH_FPTR flush;
} SYS_CONSOLE_DEV_DESC;

typedef struct {
	SYS_STATUS status;
	const SYS_CONSOLE_DEV_DESC* devDesc;
	CONSOLE_DEVICE_INDEX devIndex;
} SYS_CONSOLE_OBJECT_INSTANCE;

typedef struct {
	const void* deviceInitData;
	const SYS_CONSOLE_DEV_DESC* consDevDesc;
	uint32_t deviceIndex;
} SYS_CONSOLE_INIT;

SYS_MODULE_OBJ SYS_CONSOLE_Initialize(const SYS_MODULE_INDEX index,	const SYS_MODULE_INIT* const init);
void SYS_CONSOLE_Tasks ( SYS_MODULE_OBJ object );
SYS_STATUS SYS_CONSOLE_Status( SYS_MODULE_OBJ object );
SYS_CONSOLE_HANDLE SYS_CONSOLE_HandleGet( const SYS_MODULE_INDEX index);
SYS_CONSOLE_DEVICE SYS_CONSOLE_DeviceGet( const SYS_CONSOLE_HANDLE handle);
size_t SYS_CONSOLE_Read( const SYS_CONSOLE_HANDLE handle, void* buf, size_t count );
size_t SYS_CONSOLE_Write( const SYS_CONSOLE_HANDLE handle, const void* buf, size_t count );
bool SYS_CONSOLE_Flush(const SYS_CONSOLE_HANDLE handle);
size_t SYS_CONSOLE_ReadFreeBufferCountGet(const SYS_CONSOLE_HANDLE handle);
size_t SYS_CONSOLE_ReadCountGet(const SYS_CONSOLE_HANDLE handle);
size_t SYS_CONSOLE_WriteFreeBufferCountGet(const SYS_CONSOLE_HANDLE handle);
size_t SYS_CONSOLE_WriteCountGet(const SYS_CONSOLE_HANDLE handle);
void SYS_CONSOLE_Print(const SYS_CONSOLE_HANDLE handle, const char *format, ...);
void SYS_CONSOLE_Message(const SYS_CONSOLE_HANDLE handle, const char *message);

typedef size_t (*SYS_CONSOLE_UART_PLIB_READ)(uint8_t* pRdBuffer, const size_t size);
typedef size_t (*SYS_CONSOLE_UART_PLIB_READ_COUNT_GET)(void);
typedef size_t (*SYS_CONSOLE_UART_PLIB_READ_FREE_BUFFFER_COUNT_GET)(void);
typedef size_t (*SYS_CONSOLE_UART_PLIB_WRITE)(uint8_t* pWrBuffer, const size_t size );
typedef size_t (*SYS_CONSOLE_UART_PLIB_WRITE_COUNT_GET)(void);
typedef size_t (*SYS_CONSOLE_UART_PLIB_WRITE_FREE_BUFFER_COUNT_GET)(void);

typedef struct {
	SYS_CONSOLE_UART_PLIB_READ 							read;
	SYS_CONSOLE_UART_PLIB_READ_COUNT_GET				readCountGet;
	SYS_CONSOLE_UART_PLIB_READ_FREE_BUFFFER_COUNT_GET	readFreeBufferCountGet;
	SYS_CONSOLE_UART_PLIB_WRITE 						write;
	SYS_CONSOLE_UART_PLIB_WRITE_COUNT_GET				writeCountGet;
	SYS_CONSOLE_UART_PLIB_WRITE_FREE_BUFFER_COUNT_GET	writeFreeBufferCountGet;
} SYS_CONSOLE_UART_PLIB_INTERFACE;

typedef struct {
	const SYS_CONSOLE_UART_PLIB_INTERFACE* 				uartPLIB;
} SYS_CONSOLE_UART_INIT_DATA;

typedef struct
{
	/* Pointer to USART APIs used by the console system service*/
	const SYS_CONSOLE_UART_PLIB_INTERFACE* uartPLIB;
	SYS_CONSOLE_STATUS status;
	/* Mutex to protect access to the transfer objects */
	osMutexId_t mutexTransferObjects;
} CONSOLE_UART_DATA;

void Console_UART_Initialize(uint32_t index, const void* initData);
SYS_CONSOLE_STATUS Console_UART_Status(uint32_t index);
void Console_UART_Tasks(uint32_t index, SYS_MODULE_OBJ object);
size_t Console_UART_Read(uint32_t index, void* pRdBuffer, size_t count);
size_t Console_UART_ReadCountGet(uint32_t index);
size_t Console_UART_ReadFreeBufferCountGet(uint32_t index);
size_t Console_UART_Write(uint32_t index, const void* pWrBuffer, size_t count );
size_t Console_UART_WriteFreeBufferCountGet(uint32_t index);
size_t Console_UART_WriteCountGet(uint32_t index);
bool Console_UART_Flush(uint32_t index);

typedef enum {
	UART_DATA_8_BIT = 0x00,
	UART_DATA_9_BIT = 0x06,
	UART_DATA_INVALID = 0xFFFFFFFF
} UART_DATA;

typedef enum {
	UART_STOP_1_BIT = 0x00,
	UART_STOP_2_BIT = 0x01,
	UART_STOP_INVALID = 0xFFFFFFFF
} UART_STOP;

typedef enum {
	UART_ERROR_NONE = 0,
	UART_ERROR_OVERRUN = 0x00000002,
	UART_ERROR_FRAMING = 0x00000004,
	UART_ERROR_PARITY  = 0x00000008
} UART_ERROR;

typedef void (* UART_CALLBACK)( uintptr_t context );
typedef struct {
	uint8_t *               txBuffer;
	size_t                  txSize;
	size_t                  txProcessedSize;
	UART_CALLBACK           txCallback;
	uintptr_t               txContext;
	bool                    txBusyStatus;

	uint8_t *               rxBuffer;
	size_t                  rxSize;
	size_t                  rxProcessedSize;
	UART_CALLBACK           rxCallback;
	uintptr_t               rxContext;
	bool                    rxBusyStatus;

	volatile UART_ERROR     errors;
} UART_OBJECT ;

typedef enum {
	UART_EVENT_READ_THRESHOLD_REACHED = 0,
	UART_EVENT_READ_BUFFER_FULL,
	UART_EVENT_READ_ERROR,
	UART_EVENT_WRITE_THRESHOLD_REACHED,
}UART_EVENT;

typedef void (* UART_RING_BUFFER_CALLBACK)(UART_EVENT event, uintptr_t context );
typedef struct {
	UART_RING_BUFFER_CALLBACK                           wrCallback;
	uintptr_t                                           wrContext;
	volatile uint32_t                                   wrInIndex;
	volatile uint32_t                                   wrOutIndex;
	bool                                                isWrNotificationEnabled;
	uint32_t                                            wrThreshold;
	uint32_t                                            wrBufferSize;
	bool                                                isWrNotifyPersistently;
	UART_RING_BUFFER_CALLBACK                           rdCallback;
	uintptr_t                                           rdContext;
	volatile uint32_t                                   rdInIndex;
	volatile uint32_t                                   rdOutIndex;
	uint32_t                                            rdBufferSize;
	bool                                                isRdNotificationEnabled;
	uint32_t                                            rdThreshold;
	bool                                                isRdNotifyPersistently;
	volatile UART_ERROR                                 errors;
} UART_RING_BUFFER_OBJECT;

size_t UART_Write(uint8_t* pWrBuffer, const size_t size );
size_t UART_WriteCountGet(void);
size_t UART_WriteFreeBufferCountGet(void);
size_t UART_Read(uint8_t* pRdBuffer, const size_t size);
size_t UART_ReadCountGet(void);
size_t UART_ReadFreeBufferCountGet(void);

#endif /* INC_HEAD_HEAD_CONSOLE_H_ */
